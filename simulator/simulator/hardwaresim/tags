!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACTIVATIONFUNC_H_	ActivationFunc.h	3;"	d
ADDER_H_	Adder.h	40;"	d
ALLOBJ	makefile	/^ALLOBJ := $(ALLSRC:.cpp=.o)$/;"	m
ALLSRC	makefile	/^ALLSRC := $(wildcard *.cpp)$/;"	m
AVG_RATIO_LEAK_2INPUT_NAND	constant.h	66;"	d
AVG_RATIO_LEAK_2INPUT_NOR	constant.h	68;"	d
AVG_RATIO_LEAK_3INPUT_NAND	constant.h	67;"	d
AVG_RATIO_LEAK_3INPUT_NOR	constant.h	69;"	d
ActivationFunc	ActivationFunc.cpp	/^ActivationFunc::ActivationFunc(const InputParameter& _inputParameter,$/;"	f	class:ActivationFunc
ActivationFunc	ActivationFunc.h	/^class ActivationFunc: public FunctionUnit$/;"	c
ActivationFunction	typedef.h	/^enum ActivationFunction$/;"	g
Adder	Adder.cpp	/^Adder::Adder(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:Adder
Adder	Adder.h	/^class Adder: public FunctionUnit {$/;"	c
AnalogRRAMTHU	typedef.h	/^		AnalogRRAMTHU$/;"	e	enum:Type::CellType
AreaModify	typedef.h	/^enum AreaModify$/;"	g
Area_Opt	typedef.h	/^	Area_Opt,$/;"	e	enum:DesignOptimization
BJT_access	typedef.h	/^	BJT_access,$/;"	e	enum:CellAccessType
Bias	tmp/ParameterData.h	/^	double Bias;                \/\/ customer added Bias ...$/;"	m	class:ParameterData
CMOS	typedef.h	/^	CMOS,		\/* Normal read circuit *\/$/;"	e	enum:ReadCircuitMode
CMOS_access	typedef.h	/^	CMOS_access,$/;"	e	enum:CellAccessType
COL_MODE	constant.h	84;"	d
COMPARATOR_H_	Comparator.h	40;"	d
CONSTANT_H_	constant.h	40;"	d
CONTACT_SIZE	constant.h	58;"	d
CORE_H_	Core.h	3;"	d
CURRENTSENSEAMP_H_	CurrentSenseAmp.h	41;"	d
CXX	makefile	/^CXX := g++$/;"	m
CXXFLAGS	makefile	/^CXXFLAGS := -O3 -fopenmp -std=c++0x -w	# -w disables warnings$/;"	m
CalculateArea	ActivationFunc.cpp	/^void ActivationFunc::CalculateArea(double numInput, double IOBits,$/;"	f	class:ActivationFunc
CalculateArea	Adder.cpp	/^void Adder::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:Adder
CalculateArea	Comparator.cpp	/^void Comparator::CalculateArea(double widthArray){$/;"	f	class:Comparator
CalculateArea	Core.cpp	/^void Core::CalculateArea()$/;"	f	class:Core
CalculateArea	CurrentSenseAmp.cpp	/^void CurrentSenseAmp::CalculateArea(double widthArray) {	\/\/ adjust CurrentSenseAmp area by fixing S\/A width$/;"	f	class:CurrentSenseAmp
CalculateArea	DFF.cpp	/^void DFF::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:DFF
CalculateArea	DeMux.cpp	/^void DeMux::CalculateArea(double _newHeight, double _newWidth, AreaModify _option){$/;"	f	class:DeMux
CalculateArea	DecoderDriver.cpp	/^void DecoderDriver::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:DecoderDriver
CalculateArea	HWsim.cpp	/^void HWsim::CalculateArea()$/;"	f	class:HWsim
CalculateArea	HWsim.py	/^    def CalculateArea(self):$/;"	m	class:HWsim
CalculateArea	LUT.cpp	/^void LUT::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:LUT
CalculateArea	MultilevelSAEncoder.cpp	/^void MultilevelSAEncoder::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:MultilevelSAEncoder
CalculateArea	MultilevelSenseAmp.cpp	/^void MultilevelSenseAmp::CalculateArea(double heightArray, double widthArray, AreaModify _option) {$/;"	f	class:MultilevelSenseAmp
CalculateArea	Mux.cpp	/^void Mux::CalculateArea(double _newHeight, double _newWidth, AreaModify _option){$/;"	f	class:Mux
CalculateArea	NewSwitchMatrix.cpp	/^void NewSwitchMatrix::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:NewSwitchMatrix
CalculateArea	Precharger.cpp	/^void Precharger::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:Precharger
CalculateArea	ReadCircuit.cpp	/^void ReadCircuit::CalculateArea(double _newWidth) {	\/\/ Just add up the area of all the components$/;"	f	class:ReadCircuit
CalculateArea	RippleCounter.cpp	/^void RippleCounter::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:RippleCounter
CalculateArea	RowDecoder.cpp	/^void RowDecoder::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:RowDecoder
CalculateArea	SRAMWriteDriver.cpp	/^void SRAMWriteDriver::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:SRAMWriteDriver
CalculateArea	SenseAmp.cpp	/^void SenseAmp::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:SenseAmp
CalculateArea	ShiftAdd.cpp	/^void ShiftAdd::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:ShiftAdd
CalculateArea	SubArray.cpp	/^void SubArray::CalculateArea() {  \/\/calculate layout area for total design$/;"	f	class:SubArray
CalculateArea	Sum.cpp	/^void Sum::CalculateArea(double heightArray,  double widthArray, AreaModify _option) $/;"	f	class:Sum
CalculateArea	SwitchMatrix.cpp	/^void SwitchMatrix::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:SwitchMatrix
CalculateArea	VoltageSenseAmp.cpp	/^void VoltageSenseAmp::CalculateArea(double _widthVoltageSenseAmp) {	\/\/ Just add up the area of all the components$/;"	f	class:VoltageSenseAmp
CalculateArea	WLDecoderOutput.cpp	/^void WLDecoderOutput::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:WLDecoderOutput
CalculateArea	WLNewDecoderDriver.cpp	/^void WLNewDecoderDriver::CalculateArea(double _newHeight, double _newWidth, AreaModify _option) {$/;"	f	class:WLNewDecoderDriver
CalculateArea	build/lib.linux-x86_64-2.7/HWsim.py	/^    def CalculateArea(self):$/;"	m	class:HWsim
CalculateArea	tmp/HWsim.py	/^    def CalculateArea(self):$/;"	m	class:HWsim
CalculateDrainCap	formula.cpp	/^double CalculateDrainCap($/;"	f
CalculateGateArea	formula.cpp	/^double CalculateGateArea(	\/\/ Calculate layout area and width of logic gate given fixed layout height$/;"	f
CalculateGateCap	formula.cpp	/^double CalculateGateCap(double width, Technology tech) {$/;"	f
CalculateGateCapacitance	formula.cpp	/^void CalculateGateCapacitance($/;"	f
CalculateGateLeakage	formula.cpp	/^double CalculateGateLeakage($/;"	f
CalculateLatency	ActivationFunc.cpp	/^void ActivationFunc::CalculateLatency(double _rampInput, double _capLoad, double numRead)$/;"	f	class:ActivationFunc
CalculateLatency	Adder.cpp	/^void Adder::CalculateLatency(double _rampInput, double _capLoad, double numRead){$/;"	f	class:Adder
CalculateLatency	Comparator.cpp	/^void Comparator::CalculateLatency(double _rampInput, double _capLoad, double numRead){$/;"	f	class:Comparator
CalculateLatency	Core.cpp	/^void Core::CalculateLatency(double _rampInput)$/;"	f	class:Core
CalculateLatency	CurrentSenseAmp.cpp	/^void CurrentSenseAmp::CalculateLatency(double numRead, int currentlevel) {$/;"	f	class:CurrentSenseAmp
CalculateLatency	DFF.cpp	/^void DFF::CalculateLatency(double _rampInput, double numRead){$/;"	f	class:DFF
CalculateLatency	DeMux.cpp	/^void DeMux::CalculateLatency(double _rampInput, double numRead) {	\/\/ rampInput actually is not used$/;"	f	class:DeMux
CalculateLatency	DecoderDriver.cpp	/^void DecoderDriver::CalculateLatency(double _rampInput, double _capLoad1, double _capLoad2, double _resLoad, double numRead, double numWrite) {$/;"	f	class:DecoderDriver
CalculateLatency	HWsim.cpp	/^void HWsim::CalculateLatency()$/;"	f	class:HWsim
CalculateLatency	HWsim.py	/^    def CalculateLatency(self):$/;"	m	class:HWsim
CalculateLatency	LUT.cpp	/^void LUT::CalculateLatency(double _capLoad, double numRead) {$/;"	f	class:LUT
CalculateLatency	MultilevelSAEncoder.cpp	/^void MultilevelSAEncoder::CalculateLatency(double _rampInput, double numRead){$/;"	f	class:MultilevelSAEncoder
CalculateLatency	MultilevelSenseAmp.cpp	/^void MultilevelSenseAmp::CalculateLatency(double numRead) {$/;"	f	class:MultilevelSenseAmp
CalculateLatency	Mux.cpp	/^void Mux::CalculateLatency(double _rampInput, double _capLoad, double numRead) {  \/\/ rampInput is from SL\/BL, not fron EN signal$/;"	f	class:Mux
CalculateLatency	NewSwitchMatrix.cpp	/^void NewSwitchMatrix::CalculateLatency(double _rampInput, double _capLoad, double _resLoad, double numRead, double numWrite) {	\/\/ For simplicity, assume shift register is ideal$/;"	f	class:NewSwitchMatrix
CalculateLatency	Precharger.cpp	/^void Precharger::CalculateLatency(double _rampInput, double _capLoad, double numRead, double numWrite){$/;"	f	class:Precharger
CalculateLatency	ReadCircuit.cpp	/^void ReadCircuit::CalculateLatency(double numRead) {$/;"	f	class:ReadCircuit
CalculateLatency	RippleCounter.cpp	/^void RippleCounter::CalculateLatency(double numRead) {    \/\/ numRead = number of columns share 1 S\/A$/;"	f	class:RippleCounter
CalculateLatency	RowDecoder.cpp	/^void RowDecoder::CalculateLatency(double _rampInput, double _capLoad1, double _capLoad2, double numRead, double numWrite) {$/;"	f	class:RowDecoder
CalculateLatency	SRAMWriteDriver.cpp	/^void SRAMWriteDriver::CalculateLatency(double _rampInput, double _capLoad, double _resLoad, double numWrite){$/;"	f	class:SRAMWriteDriver
CalculateLatency	SenseAmp.cpp	/^void SenseAmp::CalculateLatency(double numRead) {$/;"	f	class:SenseAmp
CalculateLatency	ShiftAdd.cpp	/^void ShiftAdd::CalculateLatency(double numRead) {$/;"	f	class:ShiftAdd
CalculateLatency	SubArray.cpp	/^void SubArray::CalculateLatency(double _rampInput) {   \/\/calculate latency for different mode $/;"	f	class:SubArray
CalculateLatency	Sum.cpp	/^void Sum::CalculateLatency(double numRead)$/;"	f	class:Sum
CalculateLatency	SwitchMatrix.cpp	/^void SwitchMatrix::CalculateLatency(double _rampInput, double _capLoad, double _resLoad, double numRead, double numWrite) {	\/\/ For simplicity, assume shift register is ideal$/;"	f	class:SwitchMatrix
CalculateLatency	VoltageSenseAmp.cpp	/^void VoltageSenseAmp::CalculateLatency(double capInputLoad, double numRead) {$/;"	f	class:VoltageSenseAmp
CalculateLatency	WLDecoderOutput.cpp	/^void WLDecoderOutput::CalculateLatency(double _rampInput, double _capLoad, double _resLoad, double numRead, double numWrite) {$/;"	f	class:WLDecoderOutput
CalculateLatency	WLNewDecoderDriver.cpp	/^void WLNewDecoderDriver::CalculateLatency(double _rampInput, double _capLoad, double _resLoad, double numRead, double numWrite) {$/;"	f	class:WLNewDecoderDriver
CalculateLatency	build/lib.linux-x86_64-2.7/HWsim.py	/^    def CalculateLatency(self):$/;"	m	class:HWsim
CalculateLatency	tmp/HWsim.py	/^    def CalculateLatency(self):$/;"	m	class:HWsim
CalculateOnResistance	formula.cpp	/^double CalculateOnResistance(double width, int type, double temperature, Technology tech) {$/;"	f
CalculatePassGateArea	formula.cpp	/^double CalculatePassGateArea(	\/\/ Calculate layout area, height and width of pass gate given the number of folding on the pass gate width$/;"	f
CalculatePower	ActivationFunc.cpp	/^void ActivationFunc::CalculatePower(double numRead) $/;"	f	class:ActivationFunc
CalculatePower	Adder.cpp	/^void Adder::CalculatePower(double numRead, int numAdderPerOperation) {$/;"	f	class:Adder
CalculatePower	Comparator.cpp	/^void Comparator::CalculatePower(double numRead, int numComparatorPerOperation) {$/;"	f	class:Comparator
CalculatePower	Core.cpp	/^void Core::CalculatePower()$/;"	f	class:Core
CalculatePower	CurrentSenseAmp.cpp	/^void CurrentSenseAmp::CalculatePower(double numRead, int currentlevel) {$/;"	f	class:CurrentSenseAmp
CalculatePower	DFF.cpp	/^void DFF::CalculatePower(double numRead, double numDffPerOperation) {$/;"	f	class:DFF
CalculatePower	DeMux.cpp	/^void DeMux::CalculatePower(double numRead) {$/;"	f	class:DeMux
CalculatePower	DecoderDriver.cpp	/^void DecoderDriver::CalculatePower(double numReadCellPerOp, double numWriteCellPerOp, double numRead, double numWrite) {$/;"	f	class:DecoderDriver
CalculatePower	HWsim.cpp	/^void HWsim::CalculatePower()$/;"	f	class:HWsim
CalculatePower	HWsim.py	/^    def CalculatePower(self):$/;"	m	class:HWsim
CalculatePower	LUT.cpp	/^void LUT::CalculatePower(double numRead) {$/;"	f	class:LUT
CalculatePower	MultilevelSAEncoder.cpp	/^void MultilevelSAEncoder::CalculatePower(double numRead) {$/;"	f	class:MultilevelSAEncoder
CalculatePower	MultilevelSenseAmp.cpp	/^void MultilevelSenseAmp::CalculatePower(double numof1, double numof2, double numof3, double numof4, double numof5, double numof6, double numof7, double numof8, double numof9, double numof10, double numRead) {$/;"	f	class:MultilevelSenseAmp
CalculatePower	Mux.cpp	/^void Mux::CalculatePower(double numRead) {$/;"	f	class:Mux
CalculatePower	NewSwitchMatrix.cpp	/^void NewSwitchMatrix::CalculatePower(double numRead, double numWrite) {      $/;"	f	class:NewSwitchMatrix
CalculatePower	Precharger.cpp	/^void Precharger::CalculatePower(double numRead, double numWrite) {$/;"	f	class:Precharger
CalculatePower	ReadCircuit.cpp	/^void ReadCircuit::CalculatePower(double numRead) {$/;"	f	class:ReadCircuit
CalculatePower	RippleCounter.cpp	/^void RippleCounter::CalculatePower(double numRead) {$/;"	f	class:RippleCounter
CalculatePower	RowDecoder.cpp	/^void RowDecoder::CalculatePower(double numRead, double numWrite) {$/;"	f	class:RowDecoder
CalculatePower	SRAMWriteDriver.cpp	/^void SRAMWriteDriver::CalculatePower(double numWrite) {$/;"	f	class:SRAMWriteDriver
CalculatePower	SenseAmp.cpp	/^void SenseAmp::CalculatePower(double numRead) {$/;"	f	class:SenseAmp
CalculatePower	ShiftAdd.cpp	/^void ShiftAdd::CalculatePower(double numRead) {$/;"	f	class:ShiftAdd
CalculatePower	SubArray.cpp	/^void SubArray::CalculatePower() {$/;"	f	class:SubArray
CalculatePower	Sum.cpp	/^void Sum::CalculatePower(double numRead) $/;"	f	class:Sum
CalculatePower	SwitchMatrix.cpp	/^void SwitchMatrix::CalculatePower(double numRead, double numWrite) {$/;"	f	class:SwitchMatrix
CalculatePower	VoltageSenseAmp.cpp	/^void VoltageSenseAmp::CalculatePower(double numRead) {$/;"	f	class:VoltageSenseAmp
CalculatePower	WLDecoderOutput.cpp	/^void WLDecoderOutput::CalculatePower(double numRead, double numWrite) {$/;"	f	class:WLDecoderOutput
CalculatePower	WLNewDecoderDriver.cpp	/^void WLNewDecoderDriver::CalculatePower(double numRead, double numWrite) {$/;"	f	class:WLNewDecoderDriver
CalculatePower	build/lib.linux-x86_64-2.7/HWsim.py	/^    def CalculatePower(self):$/;"	m	class:HWsim
CalculatePower	tmp/HWsim.py	/^    def CalculatePower(self):$/;"	m	class:HWsim
CalculateTransconductance	formula.cpp	/^double CalculateTransconductance(double width, int type, Technology tech) {$/;"	f
CalculateUnitArea	Comparator.cpp	/^void Comparator::CalculateUnitArea(AreaModify _option) {$/;"	f	class:Comparator
CalculateUnitArea	CurrentSenseAmp.cpp	/^void CurrentSenseAmp::CalculateUnitArea() {$/;"	f	class:CurrentSenseAmp
CalculateUnitArea	ReadCircuit.cpp	/^void ReadCircuit::CalculateUnitArea() {$/;"	f	class:ReadCircuit
CalculateUnitArea	VoltageSenseAmp.cpp	/^void VoltageSenseAmp::CalculateUnitArea() {$/;"	f	class:VoltageSenseAmp
CellAccessType	typedef.h	/^enum CellAccessType$/;"	g
CellBits	ReadParam.h	/^	int CellBits;					$/;"	m	class:ReadParam
CellType	typedef.h	/^	enum CellType {$/;"	g	namespace:Type
Comparator	Comparator.cpp	/^Comparator::Comparator(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:Comparator
Comparator	Comparator.h	/^class Comparator: public FunctionUnit {$/;"	c
Core	Core.cpp	/^Core::Core(InputParameter& _inputParameter, Technology& _tech,$/;"	f	class:Core
Core	Core.h	/^class Core: public FunctionUnit {$/;"	c
CurrentSenseAmp	CurrentSenseAmp.cpp	/^CurrentSenseAmp::CurrentSenseAmp(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:CurrentSenseAmp
CurrentSenseAmp	CurrentSenseAmp.h	/^class CurrentSenseAmp: public FunctionUnit {$/;"	c
DEMUX_H_	DeMux.h	40;"	d
DFF	DFF.cpp	/^DFF::DFF(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:DFF
DFF	DFF.h	/^class DFF: public FunctionUnit {$/;"	c
DFF_H_	DFF.h	40;"	d
DeMux	DeMux.cpp	/^DeMux::DeMux(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:DeMux
DeMux	DeMux.h	/^class DeMux: public FunctionUnit {$/;"	c
DecoderDriver	DecoderDriver.cpp	/^DecoderDriver::DecoderDriver(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:DecoderDriver
DecoderDriver	DecoderDriver.h	/^class DecoderDriver: public FunctionUnit {$/;"	c
DecoderDriver_H_	DecoderDriver.h	40;"	d
DecoderMode	typedef.h	/^enum DecoderMode$/;"	g
DesignMode	typedef.h	/^enum DesignMode$/;"	g
DesignOptimization	typedef.h	/^enum DesignOptimization$/;"	g
DeviceRoadmap	typedef.h	/^enum DeviceRoadmap$/;"	g
DigitalComplementalCode	typedef.h	/^	DigitalComplementalCode$/;"	e	enum:DesignMode
DigitalRRAMTHU	typedef.h	/^		DigitalRRAMTHU,$/;"	e	enum:Type::CellType
FET_2D	typedef.h	/^	FET_2D,			\/* 2D FET *\/$/;"	e	enum:TransistorType
FPGA	MultilevelSenseAmp.h	/^	bool FPGA;$/;"	m	class:MultilevelSenseAmp
FPGA	Mux.h	/^	bool FPGA;$/;"	m	class:Mux
FPGA	Precharger.h	/^	bool FPGA;$/;"	m	class:Precharger
FPGA	SRAMWriteDriver.h	/^	bool FPGA;$/;"	m	class:SRAMWriteDriver
FPGA	SenseAmp.h	/^	bool FPGA;$/;"	m	class:SenseAmp
FPGA	SubArray.h	/^	bool FPGA;			\/\/ FPGA mode$/;"	m	class:SubArray
FULL_Opt	typedef.h	/^	FULL_Opt$/;"	e	enum:DesignOptimization
FUNCTIONUNIT_H_	FunctionUnit.h	40;"	d
FileList	tmp/addstring.py	/^FileList = os.listdir(".")$/;"	v
FileList	tmp/addstring2.py	/^FileList = os.listdir(".")$/;"	v
FirstLayer	SubArray.h	/^	bool FirstLayer;       \/\/ First layer ANN$/;"	m	class:SubArray
Func	ActivationFunc.h	/^	ActivationFunction Func;$/;"	m	class:ActivationFunc
FunctionUnit	FunctionUnit.cpp	/^FunctionUnit::FunctionUnit() {$/;"	f	class:FunctionUnit
FunctionUnit	FunctionUnit.h	/^class FunctionUnit {$/;"	c
FunctionUnit	HWsim.py	/^class FunctionUnit(_object):$/;"	c
FunctionUnit	build/lib.linux-x86_64-2.7/HWsim.py	/^class FunctionUnit(_object):$/;"	c
FunctionUnit	tmp/HWsim.py	/^class FunctionUnit(_object):$/;"	c
FunctionUnit_swigregister	HWsim.py	/^FunctionUnit_swigregister = _HWsim.FunctionUnit_swigregister$/;"	v
FunctionUnit_swigregister	build/lib.linux-x86_64-2.7/HWsim.py	/^FunctionUnit_swigregister = _HWsim.FunctionUnit_swigregister$/;"	v
FunctionUnit_swigregister	tmp/HWsim.py	/^FunctionUnit_swigregister = _HWsim.FunctionUnit_swigregister$/;"	v
GCC_HASCLASSVISIBILITY	HWsim_wrap.cxx	111;"	d	file:
HEIGHT_WIDTH_RATIO_LIMIT	constant.h	79;"	d
HP	typedef.h	/^	HP,		\/* High performance *\/$/;"	e	enum:DeviceRoadmap
HWSIM_H_	HWsim.h	3;"	d
HWsim	HWsim.cpp	/^HWsim::HWsim()$/;"	f	class:HWsim
HWsim	HWsim.h	/^class HWsim: public FunctionUnit {$/;"	c
HWsim	HWsim.py	/^class HWsim(FunctionUnit):$/;"	c
HWsim	build/lib.linux-x86_64-2.7/HWsim.py	/^class HWsim(FunctionUnit):$/;"	c
HWsim	tmp/HWsim.py	/^class HWsim(FunctionUnit):$/;"	c
HWsim_swigregister	HWsim.py	/^HWsim_swigregister = _HWsim.HWsim_swigregister$/;"	v
HWsim_swigregister	build/lib.linux-x86_64-2.7/HWsim.py	/^HWsim_swigregister = _HWsim.HWsim_swigregister$/;"	v
HWsim_swigregister	tmp/HWsim.py	/^HWsim_swigregister = _HWsim.HWsim_swigregister$/;"	v
INPUTPARAMETER_H_	InputParameter.h	40;"	d
INV	constant.h	42;"	d
IOBits	ReadParam.h	/^	int IOBits;$/;"	m	class:ReadParam
IR_DROP_TOLERANCE	constant.h	77;"	d
Initialize	ActivationFunc.cpp	/^void ActivationFunc::Initialize(int _numCol, int _numIOBit, ActivationFunction _Func)$/;"	f	class:ActivationFunc
Initialize	Adder.cpp	/^void Adder::Initialize(int _numBit, int _numAdder){$/;"	f	class:Adder
Initialize	Comparator.cpp	/^void Comparator::Initialize(int _numBit, int _numComparator) {$/;"	f	class:Comparator
Initialize	Core.cpp	/^void Core::Initialize(double _unitWireRes)$/;"	f	class:Core
Initialize	CurrentSenseAmp.cpp	/^void CurrentSenseAmp::Initialize(int _numCol, bool _parallel, bool _rowbyrow, double _clkFreq, int _numReadCellPerOperationNeuro) {$/;"	f	class:CurrentSenseAmp
Initialize	DFF.cpp	/^void DFF::Initialize(int _numDff, double _clkFreq){$/;"	f	class:DFF
Initialize	DeMux.cpp	/^void DeMux::Initialize(int _numInput, int numRow){$/;"	f	class:DeMux
Initialize	DecoderDriver.cpp	/^void DecoderDriver::Initialize(int _mode, int _numOutput \/* # of array rows\/columns *\/, int numLoad) {$/;"	f	class:DecoderDriver
Initialize	HWsim.cpp	/^void HWsim::Initialize()$/;"	f	class:HWsim
Initialize	HWsim.py	/^    def Initialize(self):$/;"	m	class:HWsim
Initialize	LUT.cpp	/^void LUT::Initialize(bool _SRAM, int _numYbit, int _numEntry, double _clkFreq) {$/;"	f	class:LUT
Initialize	MultilevelSAEncoder.cpp	/^void MultilevelSAEncoder::Initialize(int _numLevel, int _numEncoder){$/;"	f	class:MultilevelSAEncoder
Initialize	MultilevelSenseAmp.cpp	/^void MultilevelSenseAmp::Initialize(int _numCol, int _levelOutput, double _clkFreq, int _numReadCellPerOperationNeuro) {$/;"	f	class:MultilevelSenseAmp
Initialize	Mux.cpp	/^void Mux::Initialize(int _numInput, int _numSelection, double _resTg, bool _FPGA){$/;"	f	class:Mux
Initialize	NewSwitchMatrix.cpp	/^void NewSwitchMatrix::Initialize(int _numOutput, double _activityRowRead, double _clkFreq){$/;"	f	class:NewSwitchMatrix
Initialize	Precharger.cpp	/^void Precharger::Initialize(int _numCol, double _resLoad, bool _FPGA, bool _neuro, double _activityColWrite, int _numReadCellPerOperationFPGA, int _numWriteCellPerOperationFPGA,$/;"	f	class:Precharger
Initialize	ReadCircuit.cpp	/^void ReadCircuit::Initialize(ReadCircuitMode _mode, int _numReadCol, int _maxNumIntBit, SpikingMode _spikingMode, double _clkFreq) {$/;"	f	class:ReadCircuit
Initialize	RippleCounter.cpp	/^void RippleCounter::Initialize(int _numBit, double _clkFreq) {$/;"	f	class:RippleCounter
Initialize	RowDecoder.cpp	/^void RowDecoder::Initialize(DecoderMode _mode, int _numAddrRow, bool _MUX, bool _parallel) {$/;"	f	class:RowDecoder
Initialize	SRAMWriteDriver.cpp	/^void SRAMWriteDriver::Initialize(int _numCol, bool _FPGA, bool _neuro, double _activityColWrite, int _numWriteCellPerOperationFPGA, int _numWriteCellPerOperationMemory, int _numWriteCellPerOperationNeuro){$/;"	f	class:SRAMWriteDriver
Initialize	SenseAmp.cpp	/^void SenseAmp::Initialize(int _numCol, bool _currentSense, double _senseVoltage, double _pitchSenseAmp, bool _FPGA, bool _neuro, double _clkFreq, int _numReadCellPerOperationFPGA, int _numReadCellPerOperationMemory, int _numReadCellPerOperationNeuro) {$/;"	f	class:SenseAmp
Initialize	ShiftAdd.cpp	/^void ShiftAdd::Initialize(int _numUnit, int _numAdderBit, double _clkFreq, SpikingMode _spikingMode, int _numReadPulse) {$/;"	f	class:ShiftAdd
Initialize	SubArray.cpp	/^void SubArray::Initialize(int _numRow, int _numCol, double _unitWireRes){  \/\/initialization module$/;"	f	class:SubArray
Initialize	Sum.cpp	/^void Sum::Initialize(int _numCol, int _numSum, int _numSumBit)$/;"	f	class:Sum
Initialize	SwitchMatrix.cpp	/^void SwitchMatrix::Initialize(int _mode, int _numOutput, double _resTg, bool _neuro, bool _parallelWrite, double _activityRowRead, double _activityColWrite, int _numWriteCellPerOperationMemory, int _numWriteCellPerOperationNeuro, double _numWritePulse, double _clkFreq){$/;"	f	class:SwitchMatrix
Initialize	Technology.cpp	/^void Technology::Initialize(int _featureSizeInNano, DeviceRoadmap _deviceRoadmap, TransistorType _transistorType) {$/;"	f	class:Technology
Initialize	VoltageSenseAmp.cpp	/^void VoltageSenseAmp::Initialize(int _numReadCol, double _clkFreq) {$/;"	f	class:VoltageSenseAmp
Initialize	WLDecoderOutput.cpp	/^void WLDecoderOutput::Initialize(int _numWLRow, bool _multifunctional, bool _neuro) {$/;"	f	class:WLDecoderOutput
Initialize	WLNewDecoderDriver.cpp	/^void WLNewDecoderDriver::Initialize(int _numWLRow) {$/;"	f	class:WLNewDecoderDriver
Initialize	build/lib.linux-x86_64-2.7/HWsim.py	/^    def Initialize(self):$/;"	m	class:HWsim
Initialize	tmp/HWsim.py	/^    def Initialize(self):$/;"	m	class:HWsim
InputParameter	InputParameter.h	/^class InputParameter {$/;"	c
LLONG_MAX	HWsim_wrap.cxx	3393;"	d	file:
LLONG_MIN	HWsim_wrap.cxx	3394;"	d	file:
LSTP	typedef.h	/^	LSTP	\/* Low standby power *\/$/;"	e	enum:DeviceRoadmap
LUT	LUT.cpp	/^LUT::LUT(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), mux(_inputParameter, _tech, _cell), muxDecoder(_inputParameter, _tech, _cell), colDecoder(_inputParameter, _tech, _cell), colDecoderDriver(_inputParameter, _tech, _cell), voltageSenseAmp(_inputParameter, _tech, _cell), FunctionUnit() {$/;"	f	class:LUT
LUT	LUT.h	/^class LUT: public FunctionUnit {$/;"	c
LUT_H_	LUT.h	40;"	d
LUT_dynamic	SubArray.h	/^	bool LUT_dynamic;   \/\/ Parameter for FPGA$/;"	m	class:SubArray
Leakage_Opt	typedef.h	/^	Leakage_Opt,$/;"	e	enum:DesignOptimization
M2_PITCH	constant.h	63;"	d
M3_PITCH	constant.h	64;"	d
MAGIC	typedef.h	/^	MAGIC,		\/* Use magic folding based on the original area *\/$/;"	e	enum:AreaModify
MAINS	makefile	/^MAINS := HWsim_test.cpp  HWsimMain.cpp$/;"	m
MAX	formula.h	44;"	d
MAX_NMOS_SIZE	constant.h	49;"	d
MAX_TRANSISTOR_HEIGHT	constant.h	52;"	d
MIN	formula.h	45;"	d
MIN_GAP_BET_CONTACT_POLY	constant.h	57;"	d
MIN_GAP_BET_FIELD_POLY	constant.h	61;"	d
MIN_GAP_BET_GATE_POLY	constant.h	56;"	d
MIN_GAP_BET_P_AND_N_DIFFS	constant.h	54;"	d
MIN_GAP_BET_SAME_TYPE_DIFFS	constant.h	55;"	d
MIN_NMOS_SIZE	constant.h	50;"	d
MIN_POLY_EXT_DIFF	constant.h	60;"	d
MIN_WIDTH_POWER_RAIL	constant.h	59;"	d
MULTILEVELSENSEAMP_H_	MultilevelSenseAmp.h	40;"	d
MUX	RowDecoder.h	/^	bool MUX;	\/\/ MUX mode$/;"	m	class:RowDecoder
MUX_H_	Mux.h	40;"	d
MagicLayout	FunctionUnit.cpp	/^void FunctionUnit::MagicLayout() {$/;"	f	class:FunctionUnit
MagicLayout	HWsim.py	/^    def MagicLayout(self):$/;"	m	class:FunctionUnit
MagicLayout	build/lib.linux-x86_64-2.7/HWsim.py	/^    def MagicLayout(self):$/;"	m	class:FunctionUnit
MagicLayout	tmp/HWsim.py	/^    def MagicLayout(self):$/;"	m	class:FunctionUnit
MemCell	MemCell.h	/^class MemCell {$/;"	c
MemCellType	typedef.h	/^	enum MemCellType {$/;"	g	namespace:Type
MultilevelSAEncoder	MultilevelSAEncoder.cpp	/^MultilevelSAEncoder::MultilevelSAEncoder(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:MultilevelSAEncoder
MultilevelSAEncoder	MultilevelSAEncoder.h	/^class MultilevelSAEncoder: public FunctionUnit {$/;"	c
MultilevelSAEncoder_H_	MultilevelSAEncoder.h	40;"	d
MultilevelSenseAmp	MultilevelSenseAmp.cpp	/^MultilevelSenseAmp::MultilevelSenseAmp(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), currentSenseAmp(_inputParameter, _tech, _cell), FunctionUnit() {$/;"	f	class:MultilevelSenseAmp
MultilevelSenseAmp	MultilevelSenseAmp.h	/^class MultilevelSenseAmp: public FunctionUnit {$/;"	c
Mux	Mux.cpp	/^Mux::Mux(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:Mux
Mux	Mux.h	/^class Mux: public FunctionUnit {$/;"	c
NAND	constant.h	44;"	d
NEUROSIM_FORMULA_H_	formula.h	40;"	d
NEWSWITCHMATRIX_H_	NewSwitchMatrix.h	40;"	d
NMOS	constant.h	46;"	d
NONE	typedef.h	/^	NONE,		\/* No action, just use the original area calculation *\/$/;"	e	enum:AreaModify
NONSPIKING	typedef.h	/^	NONSPIKING,	\/* Binary format *\/$/;"	e	enum:SpikingMode
NOR	constant.h	43;"	d
NewSwitchMatrix	NewSwitchMatrix.cpp	/^NewSwitchMatrix::NewSwitchMatrix(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), dff(_inputParameter, _tech, _cell), FunctionUnit() {$/;"	f	class:NewSwitchMatrix
NewSwitchMatrix	NewSwitchMatrix.h	/^class NewSwitchMatrix: public FunctionUnit {$/;"	c
None	typedef.h	/^	None,$/;"	e	enum:DesignOptimization
NonlinearResistance	formula.cpp	/^double NonlinearResistance(double R, double NL, double Vw, double Vr, double V) {	\/\/ Nonlinearity is the current ratio between Vw and V, and R means the resistance at Vr$/;"	f
NormalizedMax	tmp/ParameterData.h	/^	double NormalizedMax;       \/\/ Max value of normalized weight matrix data$/;"	m	class:ParameterData
NormalizedMin	tmp/ParameterData.h	/^	double NormalizedMin;      \/\/ Min value of normalized weight matrix data$/;"	m	class:ParameterData
OBJ	makefile	/^OBJ := $(SRC:.cpp=.o)$/;"	m
OSCILLATION	typedef.h	/^	OSCILLATION	\/* NbO2 *\/$/;"	e	enum:ReadCircuitMode
OVERRIDE	typedef.h	/^	OVERRIDE	\/* directly modify the height and width and calculate new area *\/$/;"	e	enum:AreaModify
OverrideLayout	FunctionUnit.cpp	/^void FunctionUnit::OverrideLayout() {$/;"	f	class:FunctionUnit
OverrideLayout	HWsim.py	/^    def OverrideLayout(self):$/;"	m	class:FunctionUnit
OverrideLayout	build/lib.linux-x86_64-2.7/HWsim.py	/^    def OverrideLayout(self):$/;"	m	class:FunctionUnit
OverrideLayout	tmp/HWsim.py	/^    def OverrideLayout(self):$/;"	m	class:FunctionUnit
PARAMETERDATA_H_	tmp/ParameterData.h	4;"	d
PMOS	constant.h	47;"	d
POLY_WIDTH	constant.h	62;"	d
PRECHARGER_H_	Precharger.h	40;"	d
PY_SSIZE_T_MAX	HWsim_wrap.cxx	918;"	d	file:
PY_SSIZE_T_MIN	HWsim_wrap.cxx	919;"	d	file:
ParameterData	tmp/ParameterData.cpp	/^ParameterData::ParameterData()$/;"	f	class:ParameterData
ParameterData	tmp/ParameterData.h	/^class ParameterData$/;"	c
PitchFin	Technology.h	/^	double PitchFin;	\/* Fin pitch, Unit: m *\/$/;"	m	class:Technology
Precharger	Precharger.cpp	/^Precharger::Precharger(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:Precharger
Precharger	Precharger.h	/^class Precharger: public FunctionUnit {$/;"	c
PrintParameter	ReadParam.cpp	/^void ReadParam::PrintParameter() $/;"	f	class:ReadParam
PrintProperty	ActivationFunc.cpp	/^void ActivationFunc::PrintProperty(const char* str) {$/;"	f	class:ActivationFunc
PrintProperty	Adder.cpp	/^void Adder::PrintProperty(const char* str) {$/;"	f	class:Adder
PrintProperty	Comparator.cpp	/^void Comparator::PrintProperty(const char* str) {$/;"	f	class:Comparator
PrintProperty	Core.cpp	/^void Core::PrintProperty()$/;"	f	class:Core
PrintProperty	CurrentSenseAmp.cpp	/^void CurrentSenseAmp::PrintProperty(const char* str) {$/;"	f	class:CurrentSenseAmp
PrintProperty	DFF.cpp	/^void DFF::PrintProperty(const char* str) {$/;"	f	class:DFF
PrintProperty	DeMux.cpp	/^void DeMux::PrintProperty(const char* str) {$/;"	f	class:DeMux
PrintProperty	DecoderDriver.cpp	/^void DecoderDriver::PrintProperty(const char* str) {$/;"	f	class:DecoderDriver
PrintProperty	FunctionUnit.cpp	/^void FunctionUnit::PrintProperty(const char* str) {$/;"	f	class:FunctionUnit
PrintProperty	HWsim.cpp	/^void HWsim::PrintProperty()$/;"	f	class:HWsim
PrintProperty	HWsim.py	/^    def PrintProperty(self):$/;"	m	class:HWsim
PrintProperty	HWsim.py	/^    def PrintProperty(self, str):$/;"	m	class:FunctionUnit
PrintProperty	LUT.cpp	/^void LUT::PrintProperty(const char* str) {$/;"	f	class:LUT
PrintProperty	MultilevelSAEncoder.cpp	/^void MultilevelSAEncoder::PrintProperty(const char* str) {$/;"	f	class:MultilevelSAEncoder
PrintProperty	MultilevelSenseAmp.cpp	/^void MultilevelSenseAmp::PrintProperty(const char* str) {$/;"	f	class:MultilevelSenseAmp
PrintProperty	Mux.cpp	/^void Mux::PrintProperty(const char* str) {$/;"	f	class:Mux
PrintProperty	NewSwitchMatrix.cpp	/^void NewSwitchMatrix::PrintProperty(const char* str) {$/;"	f	class:NewSwitchMatrix
PrintProperty	Precharger.cpp	/^void Precharger::PrintProperty(const char* str) {$/;"	f	class:Precharger
PrintProperty	ReadCircuit.cpp	/^void ReadCircuit::PrintProperty(const char* str) {$/;"	f	class:ReadCircuit
PrintProperty	RippleCounter.cpp	/^void RippleCounter::PrintProperty(const char* str) {$/;"	f	class:RippleCounter
PrintProperty	RowDecoder.cpp	/^void RowDecoder::PrintProperty(const char* str) {$/;"	f	class:RowDecoder
PrintProperty	SRAMWriteDriver.cpp	/^void SRAMWriteDriver::PrintProperty(const char* str) {$/;"	f	class:SRAMWriteDriver
PrintProperty	SenseAmp.cpp	/^void SenseAmp::PrintProperty(const char* str) {$/;"	f	class:SenseAmp
PrintProperty	ShiftAdd.cpp	/^void ShiftAdd::PrintProperty(const char* str) {$/;"	f	class:ShiftAdd
PrintProperty	SubArray.cpp	/^void SubArray::PrintProperty() {$/;"	f	class:SubArray
PrintProperty	Sum.cpp	/^void Sum::PrintProperty(const char* str) {$/;"	f	class:Sum
PrintProperty	SwitchMatrix.cpp	/^void SwitchMatrix::PrintProperty(const char* str) {$/;"	f	class:SwitchMatrix
PrintProperty	Technology.cpp	/^void Technology::PrintProperty() {$/;"	f	class:Technology
PrintProperty	VoltageSenseAmp.cpp	/^void VoltageSenseAmp::PrintProperty(const char* str) {$/;"	f	class:VoltageSenseAmp
PrintProperty	WLDecoderOutput.cpp	/^void WLDecoderOutput::PrintProperty(const char* str) {$/;"	f	class:WLDecoderOutput
PrintProperty	WLNewDecoderDriver.cpp	/^void WLNewDecoderDriver::PrintProperty(const char* str) {$/;"	f	class:WLNewDecoderDriver
PrintProperty	build/lib.linux-x86_64-2.7/HWsim.py	/^    def PrintProperty(self):$/;"	m	class:HWsim
PrintProperty	build/lib.linux-x86_64-2.7/HWsim.py	/^    def PrintProperty(self, str):$/;"	m	class:FunctionUnit
PrintProperty	tmp/HWsim.py	/^    def PrintProperty(self):$/;"	m	class:HWsim
PrintProperty	tmp/HWsim.py	/^    def PrintProperty(self, str):$/;"	m	class:FunctionUnit
PyBool_FromLong	HWsim_wrap.cxx	/^PyObject *PyBool_FromLong(long ok)$/;"	f	file:
PyClass_Check	HWsim_wrap.cxx	767;"	d	file:
PyDescr_NAME	HWsim_wrap.cxx	980;"	d	file:
PyDescr_TYPE	HWsim_wrap.cxx	979;"	d	file:
PyExc_StopIteration	HWsim_wrap.cxx	874;"	d	file:
PyHeapTypeObject	HWsim_wrap.cxx	/^} PyHeapTypeObject;$/;"	t	typeref:struct:__anon1	file:
PyInt_AsLong	HWsim_wrap.cxx	769;"	d	file:
PyInt_Check	HWsim_wrap.cxx	768;"	d	file:
PyInt_FromLong	HWsim_wrap.cxx	770;"	d	file:
PyInt_FromSize_t	HWsim_wrap.cxx	771;"	d	file:
PyInt_FromSize_t	HWsim_wrap.cxx	942;"	d	file:
PyModule_AddObject	HWsim_wrap.cxx	/^PyModule_AddObject(PyObject *m, char *name, PyObject *o)$/;"	f
PyNumber_AsSsize_t	HWsim_wrap.cxx	/^static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))$/;"	f	file:
PyOS_snprintf	HWsim_wrap.cxx	838;"	d	file:
PyOS_snprintf	HWsim_wrap.cxx	840;"	d	file:
PyObject_DEL	HWsim_wrap.cxx	868;"	d	file:
PyObject_Del	HWsim_wrap.cxx	865;"	d	file:
PyObject_GenericGetAttr	HWsim_wrap.cxx	877;"	d	file:
PySequence_Size	HWsim_wrap.cxx	898;"	d	file:
PyString_AS_STRING	HWsim_wrap.cxx	779;"	d	file:
PyString_AsString	HWsim_wrap.cxx	775;"	d	file:
PyString_AsStringAndSize	HWsim_wrap.cxx	891;"	d	file:
PyString_Check	HWsim_wrap.cxx	772;"	d	file:
PyString_Format	HWsim_wrap.cxx	774;"	d	file:
PyString_FromFormat	HWsim_wrap.cxx	/^PyString_FromFormat(const char *fmt, ...) {$/;"	f	file:
PyString_FromString	HWsim_wrap.cxx	773;"	d	file:
PyString_InternFromString	HWsim_wrap.cxx	777;"	d	file:
PyString_Size	HWsim_wrap.cxx	776;"	d	file:
Py_None	HWsim_wrap.cxx	1423;"	d	file:
Py_None	HWsim_wrap.cxx	1424;"	d	file:
Py_NotImplemented	HWsim_wrap.cxx	884;"	d	file:
Py_TPFLAGS_HAVE_CLASS	HWsim_wrap.cxx	778;"	d	file:
Py_TYPE	HWsim_wrap.cxx	785;"	d	file:
Py_VISIT	HWsim_wrap.cxx	946;"	d	file:
Py_ssize_t	HWsim_wrap.cxx	/^typedef int Py_ssize_t;$/;"	t	file:
RATIO_READ_THRESHOLD_VS_VOLTAGE	constant.h	81;"	d
READCIRCUIT_H_	ReadCircuit.h	40;"	d
READPARAM_H_	ReadParam.h	2;"	d
REGULAR_COL	typedef.h	/^	REGULAR_COL,	\/* Regular column mode *\/$/;"	e	enum:DecoderMode
REGULAR_ROW	typedef.h	/^	REGULAR_ROW,	\/* Regular row mode *\/$/;"	e	enum:DecoderMode
RIPPLECOUNTER_H_	RippleCounter.h	40;"	d
ROWDECODER_H_	RowDecoder.h	40;"	d
ROW_MODE	constant.h	83;"	d
RRAM	typedef.h	/^		RRAM$/;"	e	enum:Type::MemCellType
RRAMFeatureSize	Technology.h	/^	double RRAMFeatureSize;	\/* Process feature size of RRAM, Unit: m *\/$/;"	m	class:Technology
R_OSC_OFF	ReadCircuit.h	/^	double Vhold, Vth, Vrow, Vcol, R_OSC_OFF;$/;"	m	class:ReadCircuit
ReLU	typedef.h	/^	ReLU,$/;"	e	enum:ActivationFunction
ReadCircuit	ReadCircuit.cpp	/^ReadCircuit::ReadCircuit(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:ReadCircuit
ReadCircuit	ReadCircuit.h	/^class ReadCircuit: public FunctionUnit {$/;"	c
ReadCircuitMode	typedef.h	/^enum ReadCircuitMode$/;"	g
ReadDynamicEnergy_Opt	typedef.h	/^	ReadDynamicEnergy_Opt,$/;"	e	enum:DesignOptimization
ReadLatency_Opt	typedef.h	/^	ReadLatency_Opt,$/;"	e	enum:DesignOptimization
ReadParam	ReadParam.cpp	/^ReadParam::ReadParam() $/;"	f	class:ReadParam
ReadParam	ReadParam.h	/^class ReadParam {$/;"	c
ReadParameterDataFromFile	tmp/ParameterData.cpp	/^void ParameterData::ReadParameterDataFromFile(const string& ParaFileName)$/;"	f	class:ParameterData
ReadParameterFromFile	ReadParam.cpp	/^void ReadParam::ReadParameterFromFile(const string & inputFile)$/;"	f	class:ReadParam
ReadPulseBits	tmp/ParameterData.h	/^	int ReadPulseBits;$/;"	m	class:ParameterData
ReadPulseWidth	ReadParam.h	/^	double ReadPulseWidth;			\/* Read Pulse Width, Unit: s *\/$/;"	m	class:ReadParam
ReadVoltage	ReadParam.h	/^	double ReadVoltage;				\/* Read Voltage, Unit: V *\/$/;"	m	class:ReadParam
RealMax	tmp/ParameterData.h	/^    double RealMax;             \/\/ Max value of original weight matrix data $/;"	m	class:ParameterData
RealMin	tmp/ParameterData.h	/^	double RealMin;            \/\/ Min value of original weight matrix data $/;"	m	class:ParameterData
ResetPulseWidth	ReadParam.h	/^	double ResetPulseWidth;			\/* Reset Pulse Width, Unit: s *\/$/;"	m	class:ReadParam
ResetVoltage	ReadParam.h	/^	double ResetVoltage;			\/* Reset Voltage, Unit: V *\/$/;"	m	class:ReadParam
RippleCounter	RippleCounter.cpp	/^RippleCounter::RippleCounter(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), dff(_inputParameter, _tech, _cell), FunctionUnit() {$/;"	f	class:RippleCounter
RippleCounter	RippleCounter.h	/^class RippleCounter: public FunctionUnit {$/;"	c
Rmax	ReadParam.h	/^	int Rmax;						\/* Max resistance of cell, Unit: ohm *\/$/;"	m	class:ReadParam
Rmax	tmp/ParameterData.h	/^	double Rmax, Rmin, Rstep;                      \/\/ define RRAM resistance range ... Rmax=Roff, Rmin=Ron  (TsingHua Device: 25k\/265k)$/;"	m	class:ParameterData
Rmin	ReadParam.h	/^	int Rmin;						\/* Min resistance of cell, Unit: ohm *\/$/;"	m	class:ReadParam
Rmin	tmp/ParameterData.h	/^	double Rmax, Rmin, Rstep;                      \/\/ define RRAM resistance range ... Rmax=Roff, Rmin=Ron  (TsingHua Device: 25k\/265k)$/;"	m	class:ParameterData
RowDecoder	RowDecoder.cpp	/^RowDecoder::RowDecoder(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit(){$/;"	f	class:RowDecoder
RowDecoder	RowDecoder.h	/^class RowDecoder: public FunctionUnit {$/;"	c
Rstep	tmp/ParameterData.h	/^	double Rmax, Rmin, Rstep;                      \/\/ define RRAM resistance range ... Rmax=Roff, Rmin=Ron  (TsingHua Device: 25k\/265k)$/;"	m	class:ParameterData
SABits	ReadParam.h	/^	int SABits;						\/* SA bits *\/$/;"	m	class:ReadParam
SABits	tmp/ParameterData.h	/^	double SABits;$/;"	m	class:ParameterData
SENSEAMP_H_	SenseAmp.h	40;"	d
SHIFTADD_H_	ShiftAdd.h	40;"	d
SPIKING	typedef.h	/^	SPIKING$/;"	e	enum:SpikingMode
SRAM	LUT.h	/^	bool SRAM;$/;"	m	class:LUT
SRAM	typedef.h	/^		SRAM,$/;"	e	enum:Type::MemCellType
SRAMWRITEDRIVER_H_	SRAMWriteDriver.h	40;"	d
SRAMWriteDriver	SRAMWriteDriver.cpp	/^SRAMWriteDriver::SRAMWriteDriver(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:SRAMWriteDriver
SRAMWriteDriver	SRAMWriteDriver.h	/^class SRAMWriteDriver: public FunctionUnit {$/;"	c
SRC	makefile	/^SRC := $(filter-out $(MAINS),$(ALLSRC))$/;"	m
SUBARRAY_H_	SubArray.h	40;"	d
SUM_H_	Sum.h	3;"	d
SWIGEXPORT	HWsim_wrap.cxx	118;"	d	file:
SWIGEXPORT	HWsim_wrap.cxx	120;"	d	file:
SWIGEXPORT	HWsim_wrap.cxx	124;"	d	file:
SWIGEXPORT	HWsim_wrap.cxx	126;"	d	file:
SWIGINLINE	HWsim_wrap.cxx	63;"	d	file:
SWIGINLINE	HWsim_wrap.cxx	65;"	d	file:
SWIGINTERN	HWsim_wrap.cxx	100;"	d	file:
SWIGINTERNINLINE	HWsim_wrap.cxx	105;"	d	file:
SWIGPYTHON	HWsim_wrap.cxx	13;"	d	file:
SWIGPY_CAPSULE_NAME	HWsim_wrap.cxx	975;"	d	file:
SWIGPY_USE_CAPSULE	HWsim_wrap.cxx	974;"	d	file:
SWIGRUNTIME	HWsim_wrap.cxx	204;"	d	file:
SWIGRUNTIMEINLINE	HWsim_wrap.cxx	208;"	d	file:
SWIGSTDCALL	HWsim_wrap.cxx	134;"	d	file:
SWIGSTDCALL	HWsim_wrap.cxx	136;"	d	file:
SWIGTEMPLATEDISAMBIGUATOR	HWsim_wrap.cxx	50;"	d	file:
SWIGTEMPLATEDISAMBIGUATOR	HWsim_wrap.cxx	54;"	d	file:
SWIGTEMPLATEDISAMBIGUATOR	HWsim_wrap.cxx	56;"	d	file:
SWIGTYPE_p_Core	HWsim_wrap.cxx	3009;"	d	file:
SWIGTYPE_p_FunctionUnit	HWsim_wrap.cxx	3010;"	d	file:
SWIGTYPE_p_HWsim	HWsim_wrap.cxx	3011;"	d	file:
SWIGTYPE_p_InputParameter	HWsim_wrap.cxx	3012;"	d	file:
SWIGTYPE_p_MemCell	HWsim_wrap.cxx	3013;"	d	file:
SWIGTYPE_p_ReadParam	HWsim_wrap.cxx	3014;"	d	file:
SWIGTYPE_p_Technology	HWsim_wrap.cxx	3015;"	d	file:
SWIGTYPE_p_char	HWsim_wrap.cxx	3016;"	d	file:
SWIGUNUSED	HWsim_wrap.cxx	73;"	d	file:
SWIGUNUSED	HWsim_wrap.cxx	75;"	d	file:
SWIGUNUSED	HWsim_wrap.cxx	78;"	d	file:
SWIGUNUSED	HWsim_wrap.cxx	80;"	d	file:
SWIGUNUSEDPARM	HWsim_wrap.cxx	/^  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {$/;"	f
SWIGUNUSEDPARM	HWsim_wrap.cxx	/^SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))$/;"	f
SWIGUNUSEDPARM	HWsim_wrap.cxx	92;"	d	file:
SWIGUNUSEDPARM	HWsim_wrap.cxx	94;"	d	file:
SWIGVERSION	HWsim_wrap.cxx	3042;"	d	file:
SWIG_AcquirePtr	HWsim_wrap.cxx	1194;"	d	file:
SWIG_AddCast	HWsim_wrap.cxx	/^SWIGINTERNINLINE int SWIG_AddCast(int r) {$/;"	f
SWIG_AddCast	HWsim_wrap.cxx	344;"	d	file:
SWIG_AddNewMask	HWsim_wrap.cxx	320;"	d	file:
SWIG_AddTmpMask	HWsim_wrap.cxx	323;"	d	file:
SWIG_ArgError	HWsim_wrap.cxx	306;"	d	file:
SWIG_AsCharPtrAndSize	HWsim_wrap.cxx	/^SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)$/;"	f
SWIG_AsVal_bool	HWsim_wrap.cxx	/^SWIG_AsVal_bool (PyObject *obj, bool *val)$/;"	f
SWIG_AsVal_double	HWsim_wrap.cxx	/^SWIG_AsVal_double (PyObject *obj, double *val)$/;"	f
SWIG_AsVal_int	HWsim_wrap.cxx	/^SWIG_AsVal_int (PyObject * obj, int *val)$/;"	f
SWIG_AsVal_long	HWsim_wrap.cxx	/^SWIG_AsVal_long (PyObject *obj, long* val)$/;"	f
SWIG_AttributeError	HWsim_wrap.cxx	758;"	d	file:
SWIG_BADOBJ	HWsim_wrap.cxx	315;"	d	file:
SWIG_BUFFER_SIZE	HWsim_wrap.cxx	213;"	d	file:
SWIG_BUILTIN_INIT	HWsim_wrap.cxx	1406;"	d	file:
SWIG_BUILTIN_TP_INIT	HWsim_wrap.cxx	1405;"	d	file:
SWIG_CASTRANKLIMIT	HWsim_wrap.cxx	309;"	d	file:
SWIG_CASTRANKMASK	HWsim_wrap.cxx	335;"	d	file:
SWIG_CAST_NEW_MEMORY	HWsim_wrap.cxx	218;"	d	file:
SWIG_CanCastAsInteger	HWsim_wrap.cxx	/^SWIG_CanCastAsInteger(double *d, double min, double max) {$/;"	f
SWIG_CastRank	HWsim_wrap.cxx	336;"	d	file:
SWIG_CheckImplicit	HWsim_wrap.cxx	1193;"	d	file:
SWIG_CheckState	HWsim_wrap.cxx	/^SWIGINTERNINLINE int SWIG_CheckState(int r) {$/;"	f
SWIG_CheckState	HWsim_wrap.cxx	345;"	d	file:
SWIG_ConvertFunctionPtr	HWsim_wrap.cxx	1206;"	d	file:
SWIG_ConvertInstance	HWsim_wrap.cxx	1202;"	d	file:
SWIG_ConvertMember	HWsim_wrap.cxx	1210;"	d	file:
SWIG_ConvertPacked	HWsim_wrap.cxx	1198;"	d	file:
SWIG_ConvertPtr	HWsim_wrap.cxx	1182;"	d	file:
SWIG_ConvertPtrAndOwn	HWsim_wrap.cxx	1183;"	d	file:
SWIG_DelNewMask	HWsim_wrap.cxx	321;"	d	file:
SWIG_DelTmpMask	HWsim_wrap.cxx	324;"	d	file:
SWIG_DivisionByZero	HWsim_wrap.cxx	753;"	d	file:
SWIG_ERROR	HWsim_wrap.cxx	304;"	d	file:
SWIG_EXPAND_AND_QUOTE_STRING	HWsim_wrap.cxx	188;"	d	file:
SWIG_Error	HWsim_wrap.cxx	1223;"	d	file:
SWIG_ErrorType	HWsim_wrap.cxx	1222;"	d	file:
SWIG_From_bool	HWsim_wrap.cxx	/^  SWIG_From_bool  (bool value)$/;"	f
SWIG_From_double	HWsim_wrap.cxx	3287;"	d	file:
SWIG_From_int	HWsim_wrap.cxx	/^  SWIG_From_int  (int value)$/;"	f
SWIG_GetModule	HWsim_wrap.cxx	1216;"	d	file:
SWIG_IOError	HWsim_wrap.cxx	749;"	d	file:
SWIG_IndexError	HWsim_wrap.cxx	751;"	d	file:
SWIG_InitializeModule	HWsim_wrap.cxx	/^SWIG_InitializeModule(void *clientdata) {$/;"	f
SWIG_InstallConstants	HWsim_wrap.cxx	5787;"	d	file:
SWIG_InternalNewPointerObj	HWsim_wrap.cxx	1191;"	d	file:
SWIG_IsNewObj	HWsim_wrap.cxx	322;"	d	file:
SWIG_IsOK	HWsim_wrap.cxx	305;"	d	file:
SWIG_IsTmpObj	HWsim_wrap.cxx	325;"	d	file:
SWIG_MAXCASTRANK	HWsim_wrap.cxx	333;"	d	file:
SWIG_MangledTypeQuery	HWsim_wrap.cxx	3020;"	d	file:
SWIG_MangledTypeQueryModule	HWsim_wrap.cxx	/^SWIG_MangledTypeQueryModule(swig_module_info *start,$/;"	f
SWIG_MemoryError	HWsim_wrap.cxx	759;"	d	file:
SWIG_MustGetPtr	HWsim_wrap.cxx	2837;"	d	file:
SWIG_NEWOBJ	HWsim_wrap.cxx	317;"	d	file:
SWIG_NEWOBJMASK	HWsim_wrap.cxx	311;"	d	file:
SWIG_NewClientData	HWsim_wrap.cxx	1218;"	d	file:
SWIG_NewFunctionPtrObj	HWsim_wrap.cxx	1207;"	d	file:
SWIG_NewInstanceObj	HWsim_wrap.cxx	1203;"	d	file:
SWIG_NewMemberObj	HWsim_wrap.cxx	1211;"	d	file:
SWIG_NewPackedObj	HWsim_wrap.cxx	1199;"	d	file:
SWIG_NewPointerObj	HWsim_wrap.cxx	1186;"	d	file:
SWIG_NewPointerObj	HWsim_wrap.cxx	1188;"	d	file:
SWIG_NullReferenceError	HWsim_wrap.cxx	760;"	d	file:
SWIG_OK	HWsim_wrap.cxx	303;"	d	file:
SWIG_OLDOBJ	HWsim_wrap.cxx	316;"	d	file:
SWIG_OverflowError	HWsim_wrap.cxx	754;"	d	file:
SWIG_POINTER_DISOWN	HWsim_wrap.cxx	217;"	d	file:
SWIG_POINTER_EXCEPTION	HWsim_wrap.cxx	2835;"	d	file:
SWIG_POINTER_IMPLICIT_CONV	HWsim_wrap.cxx	1403;"	d	file:
SWIG_POINTER_NEW	HWsim_wrap.cxx	1401;"	d	file:
SWIG_POINTER_NOSHADOW	HWsim_wrap.cxx	1400;"	d	file:
SWIG_POINTER_OWN	HWsim_wrap.cxx	221;"	d	file:
SWIG_PYBUFFER_SIZE	HWsim_wrap.cxx	848;"	d	file:
SWIG_PYTHON_BUILD_NONE	HWsim_wrap.cxx	1416;"	d	file:
SWIG_PYTHON_DIRECTOR_NO_VTABLE	HWsim_wrap.cxx	16;"	d	file:
SWIG_PYTHON_INITIALIZE_THREADS	HWsim_wrap.cxx	1067;"	d	file:
SWIG_PYTHON_INITIALIZE_THREADS	HWsim_wrap.cxx	1098;"	d	file:
SWIG_PYTHON_INITIALIZE_THREADS	HWsim_wrap.cxx	1114;"	d	file:
SWIG_PYTHON_SLOW_GETSET_THIS	HWsim_wrap.cxx	2265;"	d	file:
SWIG_PYTHON_THREADS	HWsim_wrap.cxx	1056;"	d	file:
SWIG_PYTHON_THREAD_BEGIN_ALLOW	HWsim_wrap.cxx	1088;"	d	file:
SWIG_PYTHON_THREAD_BEGIN_ALLOW	HWsim_wrap.cxx	1093;"	d	file:
SWIG_PYTHON_THREAD_BEGIN_ALLOW	HWsim_wrap.cxx	1107;"	d	file:
SWIG_PYTHON_THREAD_BEGIN_ALLOW	HWsim_wrap.cxx	1117;"	d	file:
SWIG_PYTHON_THREAD_BEGIN_BLOCK	HWsim_wrap.cxx	1086;"	d	file:
SWIG_PYTHON_THREAD_BEGIN_BLOCK	HWsim_wrap.cxx	1091;"	d	file:
SWIG_PYTHON_THREAD_BEGIN_BLOCK	HWsim_wrap.cxx	1101;"	d	file:
SWIG_PYTHON_THREAD_BEGIN_BLOCK	HWsim_wrap.cxx	1115;"	d	file:
SWIG_PYTHON_THREAD_END_ALLOW	HWsim_wrap.cxx	1089;"	d	file:
SWIG_PYTHON_THREAD_END_ALLOW	HWsim_wrap.cxx	1094;"	d	file:
SWIG_PYTHON_THREAD_END_ALLOW	HWsim_wrap.cxx	1110;"	d	file:
SWIG_PYTHON_THREAD_END_ALLOW	HWsim_wrap.cxx	1118;"	d	file:
SWIG_PYTHON_THREAD_END_BLOCK	HWsim_wrap.cxx	1087;"	d	file:
SWIG_PYTHON_THREAD_END_BLOCK	HWsim_wrap.cxx	1092;"	d	file:
SWIG_PYTHON_THREAD_END_BLOCK	HWsim_wrap.cxx	1104;"	d	file:
SWIG_PYTHON_THREAD_END_BLOCK	HWsim_wrap.cxx	1116;"	d	file:
SWIG_PYTHON_USE_GIL	HWsim_wrap.cxx	1062;"	d	file:
SWIG_PY_BINARY	HWsim_wrap.cxx	1135;"	d	file:
SWIG_PY_POINTER	HWsim_wrap.cxx	1134;"	d	file:
SWIG_PackData	HWsim_wrap.cxx	/^SWIG_PackData(char *c, void *ptr, size_t sz) {$/;"	f
SWIG_PackDataName	HWsim_wrap.cxx	/^SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {$/;"	f
SWIG_PackVoidPtr	HWsim_wrap.cxx	/^SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {$/;"	f
SWIG_PropagateClientData	HWsim_wrap.cxx	/^SWIG_PropagateClientData(void) {$/;"	f
SWIG_Py_None	HWsim_wrap.cxx	/^SWIG_Py_None(void)$/;"	f
SWIG_Py_Void	HWsim_wrap.cxx	/^SWIG_Py_Void(void)$/;"	f
SWIG_Python_AcquirePtr	HWsim_wrap.cxx	/^SWIG_Python_AcquirePtr(PyObject *obj, int own) {$/;"	f
SWIG_Python_AddErrMesg	HWsim_wrap.cxx	/^SWIG_Python_AddErrMesg(const char* mesg, int infront)$/;"	f
SWIG_Python_AddErrorMsg	HWsim_wrap.cxx	/^SWIG_Python_AddErrorMsg(const char* mesg)$/;"	f
SWIG_Python_AppendOutput	HWsim_wrap.cxx	/^SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {$/;"	f
SWIG_Python_ArgFail	HWsim_wrap.cxx	/^SWIG_Python_ArgFail(int argnum)$/;"	f
SWIG_Python_CallFunctor	HWsim_wrap.cxx	1380;"	d	file:
SWIG_Python_CallFunctor	HWsim_wrap.cxx	1382;"	d	file:
SWIG_Python_CheckImplicit	HWsim_wrap.cxx	/^SWIG_Python_CheckImplicit(swig_type_info *ty)$/;"	f
SWIG_Python_ConvertFunctionPtr	HWsim_wrap.cxx	/^SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {$/;"	f
SWIG_Python_ConvertPacked	HWsim_wrap.cxx	/^SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {$/;"	f
SWIG_Python_ConvertPtr	HWsim_wrap.cxx	1181;"	d	file:
SWIG_Python_ConvertPtrAndOwn	HWsim_wrap.cxx	/^SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {$/;"	f
SWIG_Python_DestroyModule	HWsim_wrap.cxx	/^SWIG_Python_DestroyModule(PyObject *obj)$/;"	f
SWIG_Python_ErrorType	HWsim_wrap.cxx	/^SWIG_Python_ErrorType(int code) {$/;"	f
SWIG_Python_ExceptionType	HWsim_wrap.cxx	/^SWIG_Python_ExceptionType(swig_type_info *desc) {$/;"	f
SWIG_Python_FixMethods	HWsim_wrap.cxx	/^  SWIG_Python_FixMethods(PyMethodDef *methods,$/;"	f
SWIG_Python_GetModule	HWsim_wrap.cxx	/^SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {$/;"	f
SWIG_Python_GetSwigThis	HWsim_wrap.cxx	/^SWIG_Python_GetSwigThis(PyObject *pyobj) $/;"	f
SWIG_Python_InitShadowInstance	HWsim_wrap.cxx	/^SWIG_Python_InitShadowInstance(PyObject *args) {$/;"	f
SWIG_Python_InstallConstants	HWsim_wrap.cxx	/^  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {$/;"	f
SWIG_Python_MustGetPtr	HWsim_wrap.cxx	/^SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {$/;"	f
SWIG_Python_NewPackedObj	HWsim_wrap.cxx	/^SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {$/;"	f
SWIG_Python_NewPointerObj	HWsim_wrap.cxx	/^SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {$/;"	f
SWIG_Python_NewShadowInstance	HWsim_wrap.cxx	/^SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)$/;"	f
SWIG_Python_NonDynamicSetAttr	HWsim_wrap.cxx	/^SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {$/;"	f
SWIG_Python_Raise	HWsim_wrap.cxx	1246;"	d	file:
SWIG_Python_SetConstant	HWsim_wrap.cxx	/^SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   $/;"	f
SWIG_Python_SetConstant	HWsim_wrap.cxx	/^SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   $/;"	f
SWIG_Python_SetErrorMsg	HWsim_wrap.cxx	/^SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {$/;"	f
SWIG_Python_SetErrorObj	HWsim_wrap.cxx	/^SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {$/;"	f
SWIG_Python_SetModule	HWsim_wrap.cxx	/^SWIG_Python_SetModule(swig_module_info *swig_module) {$/;"	f
SWIG_Python_SetSwigThis	HWsim_wrap.cxx	/^SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)$/;"	f
SWIG_Python_Thread_Allow	HWsim_wrap.cxx	/^         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}$/;"	f	class:SWIG_Python_Thread_Allow
SWIG_Python_Thread_Allow	HWsim_wrap.cxx	/^       class SWIG_Python_Thread_Allow {$/;"	c	file:
SWIG_Python_Thread_Block	HWsim_wrap.cxx	/^         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}$/;"	f	class:SWIG_Python_Thread_Block
SWIG_Python_Thread_Block	HWsim_wrap.cxx	/^       class SWIG_Python_Thread_Block {$/;"	c	file:
SWIG_Python_TypeCache	HWsim_wrap.cxx	/^SWIG_Python_TypeCache(void) {$/;"	f
SWIG_Python_TypeError	HWsim_wrap.cxx	/^SWIG_Python_TypeError(const char *type, PyObject *obj)$/;"	f
SWIG_Python_TypeQuery	HWsim_wrap.cxx	/^SWIG_Python_TypeQuery(const char *type)$/;"	f
SWIG_Python_UnpackTuple	HWsim_wrap.cxx	/^SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)$/;"	f
SWIG_Python_addvarlink	HWsim_wrap.cxx	/^  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {$/;"	f
SWIG_Python_newvarlink	HWsim_wrap.cxx	/^  SWIG_Python_newvarlink(void) {$/;"	f
SWIG_Python_str_AsChar	HWsim_wrap.cxx	/^SWIG_Python_str_AsChar(PyObject *str)$/;"	f
SWIG_Python_str_DelForPy3	HWsim_wrap.cxx	819;"	d	file:
SWIG_Python_str_DelForPy3	HWsim_wrap.cxx	821;"	d	file:
SWIG_Python_str_FromChar	HWsim_wrap.cxx	/^SWIG_Python_str_FromChar(const char *c)$/;"	f
SWIG_Python_str_FromFormat	HWsim_wrap.cxx	791;"	d	file:
SWIG_Python_str_FromFormat	HWsim_wrap.cxx	793;"	d	file:
SWIG_QUOTE_STRING	HWsim_wrap.cxx	187;"	d	file:
SWIG_RUNTIME_VERSION	HWsim_wrap.cxx	183;"	d	file:
SWIG_RuntimeError	HWsim_wrap.cxx	750;"	d	file:
SWIG_STATIC_POINTER	HWsim_wrap.cxx	1390;"	d	file:
SWIG_STATIC_POINTER	HWsim_wrap.cxx	1392;"	d	file:
SWIG_SetErrorMsg	HWsim_wrap.cxx	1221;"	d	file:
SWIG_SetErrorObj	HWsim_wrap.cxx	1220;"	d	file:
SWIG_SetModule	HWsim_wrap.cxx	1217;"	d	file:
SWIG_SyntaxError	HWsim_wrap.cxx	755;"	d	file:
SWIG_SystemError	HWsim_wrap.cxx	757;"	d	file:
SWIG_TMPOBJ	HWsim_wrap.cxx	318;"	d	file:
SWIG_TMPOBJMASK	HWsim_wrap.cxx	313;"	d	file:
SWIG_TYPE_TABLE_NAME	HWsim_wrap.cxx	189;"	d	file:
SWIG_TYPE_TABLE_NAME	HWsim_wrap.cxx	191;"	d	file:
SWIG_This	HWsim_wrap.cxx	/^SWIG_This(void)$/;"	f
SWIG_TypeCast	HWsim_wrap.cxx	/^SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {$/;"	f
SWIG_TypeCheck	HWsim_wrap.cxx	/^SWIG_TypeCheck(const char *c, swig_type_info *ty) {$/;"	f
SWIG_TypeCheckStruct	HWsim_wrap.cxx	/^SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {$/;"	f
SWIG_TypeClientData	HWsim_wrap.cxx	/^SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {$/;"	f
SWIG_TypeCmp	HWsim_wrap.cxx	/^SWIG_TypeCmp(const char *nb, const char *tb) {$/;"	f
SWIG_TypeDynamicCast	HWsim_wrap.cxx	/^SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {$/;"	f
SWIG_TypeEquiv	HWsim_wrap.cxx	/^SWIG_TypeEquiv(const char *nb, const char *tb) {$/;"	f
SWIG_TypeError	HWsim_wrap.cxx	752;"	d	file:
SWIG_TypeName	HWsim_wrap.cxx	/^SWIG_TypeName(const swig_type_info *ty) {$/;"	f
SWIG_TypeNameComp	HWsim_wrap.cxx	/^SWIG_TypeNameComp(const char *f1, const char *l1,$/;"	f
SWIG_TypeNewClientData	HWsim_wrap.cxx	/^SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {$/;"	f
SWIG_TypePrettyName	HWsim_wrap.cxx	/^SWIG_TypePrettyName(const swig_type_info *type) {$/;"	f
SWIG_TypeQuery	HWsim_wrap.cxx	3019;"	d	file:
SWIG_TypeQueryModule	HWsim_wrap.cxx	/^SWIG_TypeQueryModule(swig_module_info *start,$/;"	f
SWIG_TypeRank	HWsim_wrap.cxx	330;"	d	file:
SWIG_UnknownError	HWsim_wrap.cxx	748;"	d	file:
SWIG_UnpackData	HWsim_wrap.cxx	/^SWIG_UnpackData(const char *c, void *ptr, size_t sz) {$/;"	f
SWIG_UnpackDataName	HWsim_wrap.cxx	/^SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {$/;"	f
SWIG_UnpackVoidPtr	HWsim_wrap.cxx	/^SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {$/;"	f
SWIG_VERSION	HWsim_wrap.cxx	3043;"	d	file:
SWIG_ValueError	HWsim_wrap.cxx	756;"	d	file:
SWIG_addvarlink	HWsim_wrap.cxx	5786;"	d	file:
SWIG_arg_fail	HWsim_wrap.cxx	2836;"	d	file:
SWIG_as_voidptr	HWsim_wrap.cxx	3046;"	d	file:
SWIG_as_voidptrptr	HWsim_wrap.cxx	3047;"	d	file:
SWIG_contract_assert	HWsim_wrap.cxx	3003;"	d	file:
SWIG_exception_fail	HWsim_wrap.cxx	3001;"	d	file:
SWIG_fail	HWsim_wrap.cxx	1224;"	d	file:
SWIG_globals	HWsim_wrap.cxx	/^  SWIG_globals(void) {$/;"	f
SWIG_init	HWsim_wrap.cxx	/^SWIG_init(void) {$/;"	f
SWIG_init	HWsim_wrap.cxx	3034;"	d	file:
SWIG_init	HWsim_wrap.cxx	3037;"	d	file:
SWIG_name	HWsim_wrap.cxx	3040;"	d	file:
SWIG_newvarlink	HWsim_wrap.cxx	5785;"	d	file:
SWIG_pchar_descriptor	HWsim_wrap.cxx	/^SWIG_pchar_descriptor(void)$/;"	f
SWITCHMATRIX_H_	SwitchMatrix.h	40;"	d
SaveOutput	ActivationFunc.cpp	/^void ActivationFunc::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:ActivationFunc
SaveOutput	Adder.cpp	/^void Adder::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:Adder
SaveOutput	Comparator.cpp	/^void Comparator::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:Comparator
SaveOutput	Core.cpp	/^void Core::SaveOutput(const int& CoreIndex, const char* outputFile)$/;"	f	class:Core
SaveOutput	CurrentSenseAmp.cpp	/^void CurrentSenseAmp::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:CurrentSenseAmp
SaveOutput	DFF.cpp	/^void DFF::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:DFF
SaveOutput	DeMux.cpp	/^void DeMux::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:DeMux
SaveOutput	DecoderDriver.cpp	/^void DecoderDriver::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:DecoderDriver
SaveOutput	FunctionUnit.cpp	/^void FunctionUnit::SaveOutput(const char* str, const char* outputFile) {$/;"	f	class:FunctionUnit
SaveOutput	HWsim.cpp	/^void HWsim::SaveOutput(const char* outputFile)$/;"	f	class:HWsim
SaveOutput	HWsim.py	/^    def SaveOutput(self, outputFile):$/;"	m	class:HWsim
SaveOutput	HWsim.py	/^    def SaveOutput(self, str, outputFile):$/;"	m	class:FunctionUnit
SaveOutput	LUT.cpp	/^void LUT::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:LUT
SaveOutput	MultilevelSAEncoder.cpp	/^void MultilevelSAEncoder::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:MultilevelSAEncoder
SaveOutput	MultilevelSenseAmp.cpp	/^void MultilevelSenseAmp::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:MultilevelSenseAmp
SaveOutput	Mux.cpp	/^void Mux::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:Mux
SaveOutput	NewSwitchMatrix.cpp	/^void NewSwitchMatrix::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:NewSwitchMatrix
SaveOutput	Precharger.cpp	/^void Precharger::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:Precharger
SaveOutput	ReadCircuit.cpp	/^void ReadCircuit::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:ReadCircuit
SaveOutput	RippleCounter.cpp	/^void RippleCounter::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:RippleCounter
SaveOutput	RowDecoder.cpp	/^void RowDecoder::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:RowDecoder
SaveOutput	SRAMWriteDriver.cpp	/^void SRAMWriteDriver::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:SRAMWriteDriver
SaveOutput	SenseAmp.cpp	/^void SenseAmp::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:SenseAmp
SaveOutput	ShiftAdd.cpp	/^void ShiftAdd::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:ShiftAdd
SaveOutput	SubArray.cpp	/^void SubArray::SaveOutput(const char* outputFile) {$/;"	f	class:SubArray
SaveOutput	Sum.cpp	/^void Sum::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:Sum
SaveOutput	SwitchMatrix.cpp	/^void SwitchMatrix::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:SwitchMatrix
SaveOutput	VoltageSenseAmp.cpp	/^void VoltageSenseAmp::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:VoltageSenseAmp
SaveOutput	WLDecoderOutput.cpp	/^void WLDecoderOutput::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:WLDecoderOutput
SaveOutput	WLNewDecoderDriver.cpp	/^void WLNewDecoderDriver::SaveOutput(const char* str, const char* outputFile)$/;"	f	class:WLNewDecoderDriver
SaveOutput	build/lib.linux-x86_64-2.7/HWsim.py	/^    def SaveOutput(self, outputFile):$/;"	m	class:HWsim
SaveOutput	build/lib.linux-x86_64-2.7/HWsim.py	/^    def SaveOutput(self, str, outputFile):$/;"	m	class:FunctionUnit
SaveOutput	tmp/HWsim.py	/^    def SaveOutput(self, outputFile):$/;"	m	class:HWsim
SaveOutput	tmp/HWsim.py	/^    def SaveOutput(self, str, outputFile):$/;"	m	class:FunctionUnit
SenseAmp	SenseAmp.cpp	/^SenseAmp::SenseAmp(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:SenseAmp
SenseAmp	SenseAmp.h	/^class SenseAmp: public FunctionUnit {$/;"	c
SetPulseWidth	ReadParam.h	/^	double SetPulseWidth;			\/* Set Pulse Width, Unit: s *\/$/;"	m	class:ReadParam
SetVoltage	ReadParam.h	/^	double SetVoltage;				\/* Set Voltage, Unit: V *\/$/;"	m	class:ReadParam
ShiftAdd	ShiftAdd.cpp	/^ShiftAdd::ShiftAdd(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), adder(_inputParameter, _tech, _cell), dff(_inputParameter, _tech, _cell), FunctionUnit() {$/;"	f	class:ShiftAdd
ShiftAdd	ShiftAdd.h	/^class ShiftAdd: public FunctionUnit {$/;"	c
Sigmoid	typedef.h	/^	Sigmoid,$/;"	e	enum:ActivationFunction
SpikingMode	typedef.h	/^enum SpikingMode$/;"	g
SubArray	SubArray.cpp	/^SubArray::SubArray(InputParameter& _inputParameter, Technology& _tech, MemCell& _cell):$/;"	f	class:SubArray
SubArray	SubArray.h	/^class SubArray: public FunctionUnit {$/;"	c
Sum	Sum.cpp	/^Sum::Sum(const InputParameter& _inputParameter,$/;"	f	class:Sum
Sum	Sum.h	/^class Sum: public FunctionUnit {$/;"	c
SwigMethods	HWsim_wrap.cxx	/^static PyMethodDef SwigMethods[] = {$/;"	v	file:
SwigMovePointer	HWsim_wrap.cxx	/^    SwigMovePointer(T *p) : ptr(p) { }$/;"	f	struct:SwigValueWrapper::SwigMovePointer
SwigMovePointer	HWsim_wrap.cxx	/^  struct SwigMovePointer {$/;"	s	class:SwigValueWrapper	file:
SwigPtr_PyObject	HWsim_wrap.cxx	/^    SwigPtr_PyObject() :_obj(0)$/;"	f	class:swig::SwigPtr_PyObject
SwigPtr_PyObject	HWsim_wrap.cxx	/^    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)$/;"	f	class:swig::SwigPtr_PyObject
SwigPtr_PyObject	HWsim_wrap.cxx	/^    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)$/;"	f	class:swig::SwigPtr_PyObject
SwigPtr_PyObject	HWsim_wrap.cxx	/^  class SwigPtr_PyObject {$/;"	c	namespace:swig	file:
SwigPyBuiltin_AddPublicSymbol	HWsim_wrap.cxx	/^SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {$/;"	f
SwigPyClientData	HWsim_wrap.cxx	/^} SwigPyClientData;$/;"	t	typeref:struct:__anon2	file:
SwigPyClientData_Del	HWsim_wrap.cxx	/^SwigPyClientData_Del(SwigPyClientData *data) {$/;"	f
SwigPyClientData_New	HWsim_wrap.cxx	/^SwigPyClientData_New(PyObject* obj)$/;"	f
SwigPyObject	HWsim_wrap.cxx	/^} SwigPyObject;$/;"	t	typeref:struct:__anon3	file:
SwigPyObject_Check	HWsim_wrap.cxx	/^SwigPyObject_Check(PyObject *op) {$/;"	f
SwigPyObject_GetDesc	HWsim_wrap.cxx	/^SwigPyObject_GetDesc(PyObject *self)$/;"	f
SwigPyObject_New	HWsim_wrap.cxx	/^SwigPyObject_New(void *ptr, swig_type_info *ty, int own)$/;"	f
SwigPyObject_TypeOnce	HWsim_wrap.cxx	/^SwigPyObject_TypeOnce(void) {$/;"	f
SwigPyObject_acquire	HWsim_wrap.cxx	/^SwigPyObject_acquire(PyObject *v)$/;"	f
SwigPyObject_append	HWsim_wrap.cxx	/^SwigPyObject_append(PyObject* v, PyObject* next)$/;"	f
SwigPyObject_compare	HWsim_wrap.cxx	/^SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)$/;"	f
SwigPyObject_dealloc	HWsim_wrap.cxx	/^SwigPyObject_dealloc(PyObject *v)$/;"	f
SwigPyObject_disown	HWsim_wrap.cxx	/^SwigPyObject_disown(PyObject *v)$/;"	f
SwigPyObject_format	HWsim_wrap.cxx	/^SwigPyObject_format(const char* fmt, SwigPyObject *v)$/;"	f
SwigPyObject_get___dict__	HWsim_wrap.cxx	/^SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))$/;"	f
SwigPyObject_getattr	HWsim_wrap.cxx	/^SwigPyObject_getattr(SwigPyObject *sobj,char *name)$/;"	f
SwigPyObject_hex	HWsim_wrap.cxx	/^SwigPyObject_hex(SwigPyObject *v)$/;"	f
SwigPyObject_long	HWsim_wrap.cxx	/^SwigPyObject_long(SwigPyObject *v)$/;"	f
SwigPyObject_next	HWsim_wrap.cxx	/^SwigPyObject_next(PyObject* v)$/;"	f
SwigPyObject_oct	HWsim_wrap.cxx	/^SwigPyObject_oct(SwigPyObject *v)$/;"	f
SwigPyObject_own	HWsim_wrap.cxx	/^SwigPyObject_own(PyObject *v, PyObject *args)$/;"	f
SwigPyObject_repr	HWsim_wrap.cxx	/^SwigPyObject_repr(SwigPyObject *v)$/;"	f
SwigPyObject_richcompare	HWsim_wrap.cxx	/^SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)$/;"	f
SwigPyObject_stype	HWsim_wrap.cxx	/^static swig_type_info *SwigPyObject_stype = 0;$/;"	v	file:
SwigPyObject_type	HWsim_wrap.cxx	/^SwigPyObject_type(void) {$/;"	f
SwigPyPacked	HWsim_wrap.cxx	/^} SwigPyPacked;$/;"	t	typeref:struct:__anon4	file:
SwigPyPacked_Check	HWsim_wrap.cxx	/^SwigPyPacked_Check(PyObject *op) {$/;"	f
SwigPyPacked_New	HWsim_wrap.cxx	/^SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)$/;"	f
SwigPyPacked_TypeOnce	HWsim_wrap.cxx	/^SwigPyPacked_TypeOnce(void) {$/;"	f
SwigPyPacked_UnpackData	HWsim_wrap.cxx	/^SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)$/;"	f
SwigPyPacked_compare	HWsim_wrap.cxx	/^SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)$/;"	f
SwigPyPacked_dealloc	HWsim_wrap.cxx	/^SwigPyPacked_dealloc(PyObject *v)$/;"	f
SwigPyPacked_print	HWsim_wrap.cxx	/^SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))$/;"	f
SwigPyPacked_repr	HWsim_wrap.cxx	/^SwigPyPacked_repr(SwigPyPacked *v)$/;"	f
SwigPyPacked_str	HWsim_wrap.cxx	/^SwigPyPacked_str(SwigPyPacked *v)$/;"	f
SwigPyPacked_type	HWsim_wrap.cxx	/^SwigPyPacked_type(void) {$/;"	f
SwigValueInit	HWsim_wrap.cxx	/^template <typename T> T SwigValueInit() {$/;"	f
SwigValueWrapper	HWsim_wrap.cxx	/^  SwigValueWrapper() : pointer(0) { }$/;"	f	class:SwigValueWrapper
SwigValueWrapper	HWsim_wrap.cxx	/^template<typename T> class SwigValueWrapper {$/;"	c	file:
SwigVar_PyObject	HWsim_wrap.cxx	/^    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }$/;"	f	struct:swig::SwigVar_PyObject
SwigVar_PyObject	HWsim_wrap.cxx	/^  struct SwigVar_PyObject : SwigPtr_PyObject {$/;"	s	namespace:swig	file:
SwitchMatrix	SwitchMatrix.cpp	/^SwitchMatrix::SwitchMatrix(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), dff(_inputParameter, _tech, _cell), FunctionUnit() {$/;"	f	class:SwitchMatrix
SwitchMatrix	SwitchMatrix.h	/^class SwitchMatrix: public FunctionUnit {$/;"	c
TECHNOLOGY_H_	Technology.h	40;"	d
TFET	typedef.h	/^	TFET$/;"	e	enum:TransistorType
TYPEDEF_H_	typedef.h	40;"	d
Tanh	typedef.h	/^	Tanh$/;"	e	enum:ActivationFunction
Technology	Technology.cpp	/^Technology::Technology() {$/;"	f	class:Technology
Technology	Technology.h	/^class Technology {$/;"	c
TgHeight	DecoderDriver.h	/^	double TgHeight, TgWidth;$/;"	m	class:DecoderDriver
TgHeight	NewSwitchMatrix.h	/^	double TgHeight, TgWidth;$/;"	m	class:NewSwitchMatrix
TgHeight	SwitchMatrix.h	/^	double TgHeight, TgWidth;$/;"	m	class:SwitchMatrix
TgWidth	DecoderDriver.h	/^	double TgHeight, TgWidth;$/;"	m	class:DecoderDriver
TgWidth	Mux.h	/^	double TgWidth;$/;"	m	class:Mux
TgWidth	NewSwitchMatrix.h	/^	double TgHeight, TgWidth;$/;"	m	class:NewSwitchMatrix
TgWidth	SwitchMatrix.h	/^	double TgHeight, TgWidth;$/;"	m	class:SwitchMatrix
TransistorType	typedef.h	/^enum TransistorType$/;"	g
Type	typedef.h	/^namespace Type {	\/\/ To prevent name collision$/;"	n
ULLONG_MAX	HWsim_wrap.cxx	3395;"	d	file:
VOLTAGESENSEAMP_H_	VoltageSenseAmp.h	40;"	d
Vcol	ReadCircuit.h	/^	double Vhold, Vth, Vrow, Vcol, R_OSC_OFF;$/;"	m	class:ReadCircuit
Vhold	ReadCircuit.h	/^	double Vhold, Vth, Vrow, Vcol, R_OSC_OFF;$/;"	m	class:ReadCircuit
VoltageSenseAmp	VoltageSenseAmp.cpp	/^VoltageSenseAmp::VoltageSenseAmp(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit() {$/;"	f	class:VoltageSenseAmp
VoltageSenseAmp	VoltageSenseAmp.h	/^class VoltageSenseAmp: public FunctionUnit {$/;"	c
Vread	tmp/ParameterData.h	/^	double Vread;$/;"	m	class:ParameterData
Vrow	ReadCircuit.h	/^	double Vhold, Vth, Vrow, Vcol, R_OSC_OFF;$/;"	m	class:ReadCircuit
Vth	ReadCircuit.h	/^	double Vhold, Vth, Vrow, Vcol, R_OSC_OFF;$/;"	m	class:ReadCircuit
WLDecoderOutput	WLDecoderOutput.cpp	/^WLDecoderOutput::WLDecoderOutput(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit(){$/;"	f	class:WLDecoderOutput
WLDecoderOutput	WLDecoderOutput.h	/^class WLDecoderOutput: public FunctionUnit {$/;"	c
WLDecoderOutput_H_	WLDecoderOutput.h	40;"	d
WLNewDecoderDriver	WLNewDecoderDriver.cpp	/^WLNewDecoderDriver::WLNewDecoderDriver(const InputParameter& _inputParameter, const Technology& _tech, const MemCell& _cell): inputParameter(_inputParameter), tech(_tech), cell(_cell), FunctionUnit(){$/;"	f	class:WLNewDecoderDriver
WLNewDecoderDriver	WLNewDecoderDriver.h	/^class WLNewDecoderDriver : public FunctionUnit {$/;"	c
WLNewDecoderDriver_H_	WLNewDecoderDriver.h	2;"	d
W_SENSE_EN	constant.h	74;"	d
W_SENSE_ISO	constant.h	73;"	d
W_SENSE_MUX	constant.h	75;"	d
W_SENSE_N	constant.h	72;"	d
W_SENSE_P	constant.h	71;"	d
WeightBits	ReadParam.h	/^	int WeightBits;					\/* The Number of weight bits *\/$/;"	m	class:ReadParam
WriteDynamicEnergy_Opt	typedef.h	/^	WriteDynamicEnergy_Opt,$/;"	e	enum:DesignOptimization
WriteLatency_Opt	typedef.h	/^	WriteLatency_Opt,$/;"	e	enum:DesignOptimization
XNORModeDoubleEnded	SubArray.h	/^	bool XNORModeDoubleEnded;      \/\/ XNOR Double-ended mode using parallel RRAM$/;"	m	class:SubArray
XNORModeSingleEnded	SubArray.h	/^	bool XNORModeSingleEnded;      \/\/ XNOR Single-ended mode using parallel RRAM$/;"	m	class:SubArray
_CRT_SECURE_NO_DEPRECATE	HWsim_wrap.cxx	142;"	d	file:
_DEBUG	HWsim_wrap.cxx	167;"	d	file:
_DEBUG	HWsim_wrap.cxx	169;"	d	file:
_HWsim	HWsim.py	/^    _HWsim = swig_import_helper()$/;"	v
_HWsim	build/lib.linux-x86_64-2.7/HWsim.py	/^    _HWsim = swig_import_helper()$/;"	v
_HWsim	tmp/HWsim.py	/^    _HWsim = swig_import_helper()$/;"	v
_MEMCELL_H_	MemCell.h	40;"	d
_PyLong_FromSsize_t	HWsim_wrap.cxx	780;"	d	file:
_SCL_SECURE_NO_DEPRECATE	HWsim_wrap.cxx	147;"	d	file:
_SWIG_Py_None	HWsim_wrap.cxx	/^_SWIG_Py_None(void)$/;"	f
_SWIG_This	HWsim_wrap.cxx	/^_SWIG_This(void)$/;"	f
__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES	HWsim_wrap.cxx	152;"	d	file:
__del__	HWsim.py	/^    __del__ = lambda self: None$/;"	v	class:FunctionUnit
__del__	HWsim.py	/^    __del__ = lambda self: None$/;"	v	class:HWsim
__del__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __del__ = lambda self: None$/;"	v	class:FunctionUnit
__del__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __del__ = lambda self: None$/;"	v	class:HWsim
__del__	tmp/HWsim.py	/^    __del__ = lambda self: None$/;"	v	class:FunctionUnit
__del__	tmp/HWsim.py	/^    __del__ = lambda self: None$/;"	v	class:HWsim
__getattr__	HWsim.py	/^    __getattr__ = lambda self, name: _swig_getattr(self, FunctionUnit, name)$/;"	v	class:FunctionUnit
__getattr__	HWsim.py	/^    __getattr__ = lambda self, name: _swig_getattr(self, HWsim, name)$/;"	v	class:HWsim
__getattr__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __getattr__ = lambda self, name: _swig_getattr(self, FunctionUnit, name)$/;"	v	class:FunctionUnit
__getattr__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __getattr__ = lambda self, name: _swig_getattr(self, HWsim, name)$/;"	v	class:HWsim
__getattr__	tmp/HWsim.py	/^    __getattr__ = lambda self, name: _swig_getattr(self, FunctionUnit, name)$/;"	v	class:FunctionUnit
__getattr__	tmp/HWsim.py	/^    __getattr__ = lambda self, name: _swig_getattr(self, HWsim, name)$/;"	v	class:HWsim
__init__	HWsim.py	/^    def __init__(self):$/;"	m	class:FunctionUnit
__init__	HWsim.py	/^    def __init__(self):$/;"	m	class:HWsim
__init__	build/lib.linux-x86_64-2.7/HWsim.py	/^    def __init__(self):$/;"	m	class:FunctionUnit
__init__	build/lib.linux-x86_64-2.7/HWsim.py	/^    def __init__(self):$/;"	m	class:HWsim
__init__	tmp/HWsim.py	/^    def __init__(self):$/;"	m	class:FunctionUnit
__init__	tmp/HWsim.py	/^    def __init__(self):$/;"	m	class:HWsim
__repr__	HWsim.py	/^    __repr__ = _swig_repr$/;"	v	class:FunctionUnit
__repr__	HWsim.py	/^    __repr__ = _swig_repr$/;"	v	class:HWsim
__repr__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __repr__ = _swig_repr$/;"	v	class:FunctionUnit
__repr__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __repr__ = _swig_repr$/;"	v	class:HWsim
__repr__	tmp/HWsim.py	/^    __repr__ = _swig_repr$/;"	v	class:FunctionUnit
__repr__	tmp/HWsim.py	/^    __repr__ = _swig_repr$/;"	v	class:HWsim
__setattr__	HWsim.py	/^    __setattr__ = lambda self, name, value: _swig_setattr(self, FunctionUnit, name, value)$/;"	v	class:FunctionUnit
__setattr__	HWsim.py	/^    __setattr__ = lambda self, name, value: _swig_setattr(self, HWsim, name, value)$/;"	v	class:HWsim
__setattr__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __setattr__ = lambda self, name, value: _swig_setattr(self, FunctionUnit, name, value)$/;"	v	class:FunctionUnit
__setattr__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __setattr__ = lambda self, name, value: _swig_setattr(self, HWsim, name, value)$/;"	v	class:HWsim
__setattr__	tmp/HWsim.py	/^    __setattr__ = lambda self, name, value: _swig_setattr(self, FunctionUnit, name, value)$/;"	v	class:FunctionUnit
__setattr__	tmp/HWsim.py	/^    __setattr__ = lambda self, name, value: _swig_setattr(self, HWsim, name, value)$/;"	v	class:HWsim
__swig_destroy__	HWsim.py	/^    __swig_destroy__ = _HWsim.delete_FunctionUnit$/;"	v	class:FunctionUnit
__swig_destroy__	HWsim.py	/^    __swig_destroy__ = _HWsim.delete_HWsim$/;"	v	class:HWsim
__swig_destroy__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __swig_destroy__ = _HWsim.delete_FunctionUnit$/;"	v	class:FunctionUnit
__swig_destroy__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __swig_destroy__ = _HWsim.delete_HWsim$/;"	v	class:HWsim
__swig_destroy__	tmp/HWsim.py	/^    __swig_destroy__ = _HWsim.delete_FunctionUnit$/;"	v	class:FunctionUnit
__swig_destroy__	tmp/HWsim.py	/^    __swig_destroy__ = _HWsim.delete_HWsim$/;"	v	class:HWsim
__swig_getmethods__	HWsim.py	/^    __swig_getmethods__ = {}$/;"	v	class:FunctionUnit
__swig_getmethods__	HWsim.py	/^    __swig_getmethods__ = {}$/;"	v	class:HWsim
__swig_getmethods__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __swig_getmethods__ = {}$/;"	v	class:FunctionUnit
__swig_getmethods__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __swig_getmethods__ = {}$/;"	v	class:HWsim
__swig_getmethods__	tmp/HWsim.py	/^    __swig_getmethods__ = {}$/;"	v	class:FunctionUnit
__swig_getmethods__	tmp/HWsim.py	/^    __swig_getmethods__ = {}$/;"	v	class:HWsim
__swig_setmethods__	HWsim.py	/^    __swig_setmethods__ = {}$/;"	v	class:FunctionUnit
__swig_setmethods__	HWsim.py	/^    __swig_setmethods__ = {}$/;"	v	class:HWsim
__swig_setmethods__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __swig_setmethods__ = {}$/;"	v	class:FunctionUnit
__swig_setmethods__	build/lib.linux-x86_64-2.7/HWsim.py	/^    __swig_setmethods__ = {}$/;"	v	class:HWsim
__swig_setmethods__	tmp/HWsim.py	/^    __swig_setmethods__ = {}$/;"	v	class:FunctionUnit
__swig_setmethods__	tmp/HWsim.py	/^    __swig_setmethods__ = {}$/;"	v	class:HWsim
_newclass	HWsim.py	/^    _newclass = 0$/;"	v
_newclass	HWsim.py	/^    _newclass = 1$/;"	v
_newclass	build/lib.linux-x86_64-2.7/HWsim.py	/^    _newclass = 0$/;"	v
_newclass	build/lib.linux-x86_64-2.7/HWsim.py	/^    _newclass = 1$/;"	v
_newclass	tmp/HWsim.py	/^    _newclass = 0$/;"	v
_newclass	tmp/HWsim.py	/^    _newclass = 1$/;"	v
_obj	HWsim_wrap.cxx	/^    PyObject *_obj;$/;"	m	class:swig::SwigPtr_PyObject	file:
_object	HWsim.py	/^    _object = object$/;"	v
_object	HWsim.py	/^    class _object:$/;"	c
_object	build/lib.linux-x86_64-2.7/HWsim.py	/^    _object = object$/;"	v
_object	build/lib.linux-x86_64-2.7/HWsim.py	/^    class _object:$/;"	c
_object	tmp/HWsim.py	/^    _object = object$/;"	v
_object	tmp/HWsim.py	/^    class _object:$/;"	c
_p_HWsimTo_p_FunctionUnit	HWsim_wrap.cxx	/^static void *_p_HWsimTo_p_FunctionUnit(void *x, int *SWIGUNUSEDPARM(newmemory)) {$/;"	f	file:
_swig_getattr	HWsim.py	/^def _swig_getattr(self, class_type, name):$/;"	f
_swig_getattr	build/lib.linux-x86_64-2.7/HWsim.py	/^def _swig_getattr(self, class_type, name):$/;"	f
_swig_getattr	tmp/HWsim.py	/^def _swig_getattr(self, class_type, name):$/;"	f
_swig_getattr_nondynamic	HWsim.py	/^def _swig_getattr_nondynamic(self, class_type, name, static=1):$/;"	f
_swig_getattr_nondynamic	build/lib.linux-x86_64-2.7/HWsim.py	/^def _swig_getattr_nondynamic(self, class_type, name, static=1):$/;"	f
_swig_getattr_nondynamic	tmp/HWsim.py	/^def _swig_getattr_nondynamic(self, class_type, name, static=1):$/;"	f
_swig_property	HWsim.py	/^    _swig_property = property$/;"	v
_swig_property	build/lib.linux-x86_64-2.7/HWsim.py	/^    _swig_property = property$/;"	v
_swig_property	tmp/HWsim.py	/^    _swig_property = property$/;"	v
_swig_repr	HWsim.py	/^def _swig_repr(self):$/;"	f
_swig_repr	build/lib.linux-x86_64-2.7/HWsim.py	/^def _swig_repr(self):$/;"	f
_swig_repr	tmp/HWsim.py	/^def _swig_repr(self):$/;"	f
_swig_setattr	HWsim.py	/^def _swig_setattr(self, class_type, name, value):$/;"	f
_swig_setattr	build/lib.linux-x86_64-2.7/HWsim.py	/^def _swig_setattr(self, class_type, name, value):$/;"	f
_swig_setattr	tmp/HWsim.py	/^def _swig_setattr(self, class_type, name, value):$/;"	f
_swig_setattr_nondynamic	HWsim.py	/^def _swig_setattr_nondynamic(self, class_type, name, value, static=1):$/;"	f
_swig_setattr_nondynamic	build/lib.linux-x86_64-2.7/HWsim.py	/^def _swig_setattr_nondynamic(self, class_type, name, value, static=1):$/;"	f
_swig_setattr_nondynamic	tmp/HWsim.py	/^def _swig_setattr_nondynamic(self, class_type, name, value, static=1):$/;"	f
_swigc__p_Core	HWsim_wrap.cxx	/^static swig_cast_info _swigc__p_Core[] = {  {&_swigt__p_Core, 0, 0, 0},{0, 0, 0, 0}};$/;"	v	file:
_swigc__p_FunctionUnit	HWsim_wrap.cxx	/^static swig_cast_info _swigc__p_FunctionUnit[] = {  {&_swigt__p_FunctionUnit, 0, 0, 0},  {&_swigt__p_HWsim, _p_HWsimTo_p_FunctionUnit, 0, 0},{0, 0, 0, 0}};$/;"	v	file:
_swigc__p_HWsim	HWsim_wrap.cxx	/^static swig_cast_info _swigc__p_HWsim[] = {  {&_swigt__p_HWsim, 0, 0, 0},{0, 0, 0, 0}};$/;"	v	file:
_swigc__p_InputParameter	HWsim_wrap.cxx	/^static swig_cast_info _swigc__p_InputParameter[] = {  {&_swigt__p_InputParameter, 0, 0, 0},{0, 0, 0, 0}};$/;"	v	file:
_swigc__p_MemCell	HWsim_wrap.cxx	/^static swig_cast_info _swigc__p_MemCell[] = {  {&_swigt__p_MemCell, 0, 0, 0},{0, 0, 0, 0}};$/;"	v	file:
_swigc__p_ReadParam	HWsim_wrap.cxx	/^static swig_cast_info _swigc__p_ReadParam[] = {  {&_swigt__p_ReadParam, 0, 0, 0},{0, 0, 0, 0}};$/;"	v	file:
_swigc__p_Technology	HWsim_wrap.cxx	/^static swig_cast_info _swigc__p_Technology[] = {  {&_swigt__p_Technology, 0, 0, 0},{0, 0, 0, 0}};$/;"	v	file:
_swigc__p_char	HWsim_wrap.cxx	/^static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};$/;"	v	file:
_swigt__p_Core	HWsim_wrap.cxx	/^static swig_type_info _swigt__p_Core = {"_p_Core", "Core *", 0, 0, (void*)0, 0};$/;"	v	file:
_swigt__p_FunctionUnit	HWsim_wrap.cxx	/^static swig_type_info _swigt__p_FunctionUnit = {"_p_FunctionUnit", "FunctionUnit *", 0, 0, (void*)0, 0};$/;"	v	file:
_swigt__p_HWsim	HWsim_wrap.cxx	/^static swig_type_info _swigt__p_HWsim = {"_p_HWsim", "HWsim *", 0, 0, (void*)0, 0};$/;"	v	file:
_swigt__p_InputParameter	HWsim_wrap.cxx	/^static swig_type_info _swigt__p_InputParameter = {"_p_InputParameter", "InputParameter *", 0, 0, (void*)0, 0};$/;"	v	file:
_swigt__p_MemCell	HWsim_wrap.cxx	/^static swig_type_info _swigt__p_MemCell = {"_p_MemCell", "MemCell *", 0, 0, (void*)0, 0};$/;"	v	file:
_swigt__p_ReadParam	HWsim_wrap.cxx	/^static swig_type_info _swigt__p_ReadParam = {"_p_ReadParam", "ReadParam *", 0, 0, (void*)0, 0};$/;"	v	file:
_swigt__p_Technology	HWsim_wrap.cxx	/^static swig_type_info _swigt__p_Technology = {"_p_Technology", "Technology *", 0, 0, (void*)0, 0};$/;"	v	file:
_swigt__p_char	HWsim_wrap.cxx	/^static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};$/;"	v	file:
a	build/lib.linux-x86_64-2.7/testHW.py	/^a = HWsim.HWsim()$/;"	v
a	testHW.py	/^a = HWsim.HWsim()$/;"	v
a	tmp/testHW.py	/^a = HWsim.HWsim()$/;"	v
accessType	MemCell.h	/^	CellAccessType accessType;	\/* Cell access type: CMOS, BJT, or diode *\/$/;"	m	class:MemCell
accessVoltage	MemCell.h	/^	double accessVoltage;$/;"	m	class:MemCell
accessVoltage	ReadParam.h	/^	double accessVoltage;			\/* Voltage on the gate of MOSFET in 1T1R cell, Unit: s *\/$/;"	m	class:ReadParam
activityColWrite	NewSwitchMatrix.h	/^	double activityColWrite;$/;"	m	class:NewSwitchMatrix
activityColWrite	Precharger.h	/^	double activityColWrite;$/;"	m	class:Precharger
activityColWrite	SRAMWriteDriver.h	/^	double activityColWrite;$/;"	m	class:SRAMWriteDriver
activityColWrite	SubArray.h	/^	double activityColWrite;	\/\/ Activity for # of columns in the write$/;"	m	class:SubArray
activityColWrite	SwitchMatrix.h	/^	double activityColWrite;$/;"	m	class:SwitchMatrix
activityRowRead	NewSwitchMatrix.h	/^	double activityRowRead;$/;"	m	class:NewSwitchMatrix
activityRowRead	SubArray.h	/^	double activityRowRead;		\/\/ Activity for # of rows in the read$/;"	m	class:SubArray
activityRowRead	SwitchMatrix.h	/^	double activityRowRead;$/;"	m	class:SwitchMatrix
activityRowWrite	SubArray.h	/^	double activityRowWrite;	\/\/ Activity for # of rows in the write$/;"	m	class:SubArray
adder	ShiftAdd.h	/^	Adder adder;$/;"	m	class:ShiftAdd
adder	SubArray.h	/^	Adder adder;$/;"	m	class:SubArray
adder	Sum.h	/^	Adder adder;$/;"	m	class:Sum
area	FunctionUnit.h	/^	double area;		\/* Unit: m^2 *\/$/;"	m	class:FunctionUnit
area	MemCell.h	/^	double area;			\/* Cell area, Unit: F^2 *\/$/;"	m	class:MemCell
areaArray	SubArray.h	/^	double areaArray;$/;"	m	class:SubArray
areaDff	ReadCircuit.h	/^	double areaUnit, hUnit, wUnit, areaReadBody, hReadBody, wReadBody, areaDff, hDff, wDff;$/;"	m	class:ReadCircuit
areaReadBody	ReadCircuit.h	/^	double areaUnit, hUnit, wUnit, areaReadBody, hReadBody, wReadBody, areaDff, hDff, wDff;$/;"	m	class:ReadCircuit
areaUnit	Comparator.h	/^    double areaUnit;$/;"	m	class:Comparator
areaUnit	CurrentSenseAmp.h	/^	double areaUnit;$/;"	m	class:CurrentSenseAmp
areaUnit	ReadCircuit.h	/^	double areaUnit, hUnit, wUnit, areaReadBody, hReadBody, wReadBody, areaDff, hDff, wDff;$/;"	m	class:ReadCircuit
areaUnit	VoltageSenseAmp.h	/^	double areaUnit;$/;"	m	class:VoltageSenseAmp
arrayColSize	tmp/test/test_core.cpp	/^int arrayColSize = 128;$/;"	v
arrayRowSize	tmp/test/test_core.cpp	/^int arrayRowSize = 128;$/;"	v
as_buffer	HWsim_wrap.cxx	/^  PyBufferProcs as_buffer;$/;"	m	struct:__anon1	file:
as_mapping	HWsim_wrap.cxx	/^  PyMappingMethods as_mapping;$/;"	m	struct:__anon1	file:
as_number	HWsim_wrap.cxx	/^  PyNumberMethods as_number;$/;"	m	struct:__anon1	file:
as_sequence	HWsim_wrap.cxx	/^  PySequenceMethods as_sequence;$/;"	m	struct:__anon1	file:
aspectRatio	MemCell.h	/^	double aspectRatio;		\/* Cell aspect ratio, H\/W *\/$/;"	m	class:MemCell
author	setup.py	/^        author = "THU.IME",$/;"	v
avgWeightBit	SubArray.h	/^	int avgWeightBit;		\/\/ Average weight for each synapse (value can range from 0 to numCellPerSynapse)$/;"	m	class:SubArray
backToBack	SubArray.h	/^	bool backToBack;    \/\/ Parameter for FPGA Mux (2 Mux triangles can combine into a Mux rectangle)$/;"	m	class:SubArray
blSwitchMatrix	SubArray.h	/^	SwitchMatrix    blSwitchMatrix;$/;"	m	class:SubArray
buildInPotential	Technology.h	/^	double buildInPotential;	\/* Bottom junction built-in potential(PB in BSIM4 model), Unit: V *\/	$/;"	m	class:Technology
capCellAccess	SubArray.h	/^	double capCellAccess;	\/\/ Capacitance of access device, Unit: ohm$/;"	m	class:SubArray
capCol	SubArray.h	/^	double capCol;		\/\/ Capacitance of column, Unit: F$/;"	m	class:SubArray
capDffInvInput	ReadCircuit.h	/^	double capDffTgGateN, capDffTgGateP, capDffTgDrain, capDffInvInput, capDffInvOutput, capNorInput, capNorOutput;$/;"	m	class:ReadCircuit
capDffInvOutput	ReadCircuit.h	/^	double capDffTgGateN, capDffTgGateP, capDffTgDrain, capDffInvInput, capDffInvOutput, capNorInput, capNorOutput;$/;"	m	class:ReadCircuit
capDffTgDrain	ReadCircuit.h	/^	double capDffTgGateN, capDffTgGateP, capDffTgDrain, capDffInvInput, capDffInvOutput, capNorInput, capNorOutput;$/;"	m	class:ReadCircuit
capDffTgGateN	ReadCircuit.h	/^	double capDffTgGateN, capDffTgGateP, capDffTgDrain, capDffInvInput, capDffInvOutput, capNorInput, capNorOutput;$/;"	m	class:ReadCircuit
capDffTgGateP	ReadCircuit.h	/^	double capDffTgGateN, capDffTgGateP, capDffTgDrain, capDffInvInput, capDffInvOutput, capNorInput, capNorOutput;$/;"	m	class:ReadCircuit
capDrainToChannel	Technology.h	/^	double capDrainToChannel;	\/* Junction drain to channel capacitance, Cjswg, Unit: F\/m *\/$/;"	m	class:Technology
capDriverInvInput	RowDecoder.h	/^	double capInvInput, capInvOutput, capNandInput, capNandOutput, capNorInput, capNorOutput, capDriverInvInput, capDriverInvOutput;$/;"	m	class:RowDecoder
capDriverInvOutput	RowDecoder.h	/^	double capInvInput, capInvOutput, capNandInput, capNandOutput, capNorInput, capNorOutput, capDriverInvInput, capDriverInvOutput;$/;"	m	class:RowDecoder
capEnInvInput	Mux.h	/^	double capNandInput, capNandOutput, capEnInvInput, capEnInvOutput, capMuxInvInput, capMuxInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:Mux
capEnInvOutput	Mux.h	/^	double capNandInput, capNandOutput, capEnInvInput, capEnInvOutput, capMuxInvInput, capMuxInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:Mux
capFringe	Technology.h	/^	double capFringe;		\/* Fringe capacitance, Unit: F\/m *\/$/;"	m	class:Technology
capIdealGate	Technology.h	/^	double capIdealGate;	\/* Ideal gate capacitance, Unit: F\/m *\/$/;"	m	class:Technology
capInput	ReadCircuit.h	/^	double capInput;$/;"	m	class:ReadCircuit
capInvInput	ActivationFunc.h	/^	double capInvInput, capInvOutput;$/;"	m	class:ActivationFunc
capInvInput	Comparator.h	/^	double capInvInput, capInvOutput, capNand2Input, capNand2Output, capNand3Input, capNand3Output;$/;"	m	class:Comparator
capInvInput	DFF.h	/^	double capTgDrain, capTgGateN, capTgGateP, capInvInput, capInvOutput;$/;"	m	class:DFF
capInvInput	DeMux.h	/^	double capInvInput, capInvOutput, capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:DeMux
capInvInput	DecoderDriver.h	/^	double capInvInput, capInvOutput, capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:DecoderDriver
capInvInput	MultilevelSAEncoder.h	/^	double capNandInput, capNandOutput, capNandLgInput, capNandLgOutput, capInvInput, capInvOutput;$/;"	m	class:MultilevelSAEncoder
capInvInput	ReadCircuit.h	/^	double capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain, capPmosGate, capPmosDrain, capInvInput, capInvOutput;$/;"	m	class:ReadCircuit
capInvInput	RowDecoder.h	/^	double capInvInput, capInvOutput, capNandInput, capNandOutput, capNorInput, capNorOutput, capDriverInvInput, capDriverInvOutput;$/;"	m	class:RowDecoder
capInvInput	SRAMWriteDriver.h	/^	double capInvInput, capInvOutput;$/;"	m	class:SRAMWriteDriver
capInvInput	WLDecoderOutput.h	/^	double capNorInput, capNorOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain;$/;"	m	class:WLDecoderOutput
capInvInput	WLNewDecoderDriver.h	/^	double capNandInput, capNandOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:WLNewDecoderDriver
capInvOutput	ActivationFunc.h	/^	double capInvInput, capInvOutput;$/;"	m	class:ActivationFunc
capInvOutput	Comparator.h	/^	double capInvInput, capInvOutput, capNand2Input, capNand2Output, capNand3Input, capNand3Output;$/;"	m	class:Comparator
capInvOutput	DFF.h	/^	double capTgDrain, capTgGateN, capTgGateP, capInvInput, capInvOutput;$/;"	m	class:DFF
capInvOutput	DeMux.h	/^	double capInvInput, capInvOutput, capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:DeMux
capInvOutput	DecoderDriver.h	/^	double capInvInput, capInvOutput, capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:DecoderDriver
capInvOutput	MultilevelSAEncoder.h	/^	double capNandInput, capNandOutput, capNandLgInput, capNandLgOutput, capInvInput, capInvOutput;$/;"	m	class:MultilevelSAEncoder
capInvOutput	ReadCircuit.h	/^	double capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain, capPmosGate, capPmosDrain, capInvInput, capInvOutput;$/;"	m	class:ReadCircuit
capInvOutput	RowDecoder.h	/^	double capInvInput, capInvOutput, capNandInput, capNandOutput, capNorInput, capNorOutput, capDriverInvInput, capDriverInvOutput;$/;"	m	class:RowDecoder
capInvOutput	SRAMWriteDriver.h	/^	double capInvInput, capInvOutput;$/;"	m	class:SRAMWriteDriver
capInvOutput	WLDecoderOutput.h	/^	double capNorInput, capNorOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain;$/;"	m	class:WLDecoderOutput
capInvOutput	WLNewDecoderDriver.h	/^	double capNandInput, capNandOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:WLNewDecoderDriver
capJunction	Technology.h	/^	double capJunction;		\/* Junction bottom capacitance, Cj0, Unit: F\/m^2 *\/$/;"	m	class:Technology
capLoad	ActivationFunc.h	/^	double capLoad;$/;"	m	class:ActivationFunc
capLoad	Adder.h	/^	double capLoad;$/;"	m	class:Adder
capLoad	Comparator.h	/^	double capLoad;$/;"	m	class:Comparator
capLoad	LUT.h	/^	double capSRAMCell, capLoad;$/;"	m	class:LUT
capLoad	Mux.h	/^	double capLoad;$/;"	m	class:Mux
capLoad	NewSwitchMatrix.h	/^	double capLoad;$/;"	m	class:NewSwitchMatrix
capLoad	Precharger.h	/^	double capLoad, resLoad;$/;"	m	class:Precharger
capLoad	SRAMWriteDriver.h	/^	double capLoad, resLoad;$/;"	m	class:SRAMWriteDriver
capLoad	SenseAmp.h	/^	double capLoad;			\/* Load capacitance of sense amplifier *\/$/;"	m	class:SenseAmp
capLoad	SwitchMatrix.h	/^	double capLoad;$/;"	m	class:SwitchMatrix
capLoad	WLDecoderOutput.h	/^	double capLoad;	\/* Output capacitance, unit: F *\/$/;"	m	class:WLDecoderOutput
capLoad	WLNewDecoderDriver.h	/^	double capLoad;	\/* Output capacitance, unit: F *\/$/;"	m	class:WLNewDecoderDriver
capLoad1	DecoderDriver.h	/^	double capLoad1, capLoad2;	\/* Output capacitance, unit: F *\/$/;"	m	class:DecoderDriver
capLoad1	RowDecoder.h	/^	double capLoad1;	\/\/ REGULAR: general capLoad, MUX: the NMOS Tg gates$/;"	m	class:RowDecoder
capLoad2	DecoderDriver.h	/^	double capLoad1, capLoad2;	\/* Output capacitance, unit: F *\/$/;"	m	class:DecoderDriver
capLoad2	RowDecoder.h	/^	double capLoad2;	\/\/ MUX: the PMOS Tg gates$/;"	m	class:RowDecoder
capLoadPerColumn	Precharger.h	/^	double capLoadPerColumn;$/;"	m	class:Precharger
capMuxInvInput	Mux.h	/^	double capNandInput, capNandOutput, capEnInvInput, capEnInvOutput, capMuxInvInput, capMuxInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:Mux
capMuxInvOutput	Mux.h	/^	double capNandInput, capNandOutput, capEnInvInput, capEnInvOutput, capMuxInvInput, capMuxInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:Mux
capNand2Input	Comparator.h	/^	double capInvInput, capInvOutput, capNand2Input, capNand2Output, capNand3Input, capNand3Output;$/;"	m	class:Comparator
capNand2Output	Comparator.h	/^	double capInvInput, capInvOutput, capNand2Input, capNand2Output, capNand3Input, capNand3Output;$/;"	m	class:Comparator
capNand3Input	Comparator.h	/^	double capInvInput, capInvOutput, capNand2Input, capNand2Output, capNand3Input, capNand3Output;$/;"	m	class:Comparator
capNand3Output	Comparator.h	/^	double capInvInput, capInvOutput, capNand2Input, capNand2Output, capNand3Input, capNand3Output;$/;"	m	class:Comparator
capNandInput	ActivationFunc.h	/^	double capNandInput, capNandOutput;$/;"	m	class:ActivationFunc
capNandInput	Adder.h	/^	double capNandInput, capNandOutput;$/;"	m	class:Adder
capNandInput	MultilevelSAEncoder.h	/^	double capNandInput, capNandOutput, capNandLgInput, capNandLgOutput, capInvInput, capInvOutput;$/;"	m	class:MultilevelSAEncoder
capNandInput	Mux.h	/^	double capNandInput, capNandOutput, capEnInvInput, capEnInvOutput, capMuxInvInput, capMuxInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:Mux
capNandInput	RowDecoder.h	/^	double capInvInput, capInvOutput, capNandInput, capNandOutput, capNorInput, capNorOutput, capDriverInvInput, capDriverInvOutput;$/;"	m	class:RowDecoder
capNandInput	WLNewDecoderDriver.h	/^	double capNandInput, capNandOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:WLNewDecoderDriver
capNandLgInput	MultilevelSAEncoder.h	/^	double capNandInput, capNandOutput, capNandLgInput, capNandLgOutput, capInvInput, capInvOutput;$/;"	m	class:MultilevelSAEncoder
capNandLgOutput	MultilevelSAEncoder.h	/^	double capNandInput, capNandOutput, capNandLgInput, capNandLgOutput, capInvInput, capInvOutput;$/;"	m	class:MultilevelSAEncoder
capNandOutput	ActivationFunc.h	/^	double capNandInput, capNandOutput;$/;"	m	class:ActivationFunc
capNandOutput	Adder.h	/^	double capNandInput, capNandOutput;$/;"	m	class:Adder
capNandOutput	MultilevelSAEncoder.h	/^	double capNandInput, capNandOutput, capNandLgInput, capNandLgOutput, capInvInput, capInvOutput;$/;"	m	class:MultilevelSAEncoder
capNandOutput	Mux.h	/^	double capNandInput, capNandOutput, capEnInvInput, capEnInvOutput, capMuxInvInput, capMuxInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:Mux
capNandOutput	RowDecoder.h	/^	double capInvInput, capInvOutput, capNandInput, capNandOutput, capNorInput, capNorOutput, capDriverInvInput, capDriverInvOutput;$/;"	m	class:RowDecoder
capNandOutput	WLNewDecoderDriver.h	/^	double capNandInput, capNandOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:WLNewDecoderDriver
capNmosDrain	ReadCircuit.h	/^	double capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain, capPmosGate, capPmosDrain, capInvInput, capInvOutput;$/;"	m	class:ReadCircuit
capNmosDrain	VoltageSenseAmp.h	/^	double capNmosGate, capNmosDrain, capPmosGate, capPmosDrain;$/;"	m	class:VoltageSenseAmp
capNmosDrain	WLDecoderOutput.h	/^	double capNorInput, capNorOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain;$/;"	m	class:WLDecoderOutput
capNmosGate	ReadCircuit.h	/^	double capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain, capPmosGate, capPmosDrain, capInvInput, capInvOutput;$/;"	m	class:ReadCircuit
capNmosGate	VoltageSenseAmp.h	/^	double capNmosGate, capNmosDrain, capPmosGate, capPmosDrain;$/;"	m	class:VoltageSenseAmp
capNmosGate	WLDecoderOutput.h	/^	double capNorInput, capNorOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain;$/;"	m	class:WLDecoderOutput
capNorInput	ReadCircuit.h	/^	double capDffTgGateN, capDffTgGateP, capDffTgDrain, capDffInvInput, capDffInvOutput, capNorInput, capNorOutput;$/;"	m	class:ReadCircuit
capNorInput	RowDecoder.h	/^	double capInvInput, capInvOutput, capNandInput, capNandOutput, capNorInput, capNorOutput, capDriverInvInput, capDriverInvOutput;$/;"	m	class:RowDecoder
capNorInput	WLDecoderOutput.h	/^	double capNorInput, capNorOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain;$/;"	m	class:WLDecoderOutput
capNorOutput	ReadCircuit.h	/^	double capDffTgGateN, capDffTgGateP, capDffTgDrain, capDffInvInput, capDffInvOutput, capNorInput, capNorOutput;$/;"	m	class:ReadCircuit
capNorOutput	RowDecoder.h	/^	double capInvInput, capInvOutput, capNandInput, capNandOutput, capNorInput, capNorOutput, capDriverInvInput, capDriverInvOutput;$/;"	m	class:RowDecoder
capNorOutput	WLDecoderOutput.h	/^	double capNorInput, capNorOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain;$/;"	m	class:WLDecoderOutput
capOutputBitlinePrecharger	Precharger.h	/^	double capOutputBitlinePrecharger;$/;"	m	class:Precharger
capOverlap	Technology.h	/^	double capOverlap;		\/* Overlap capacitance, Cover in MASTAR, Unit: F\/m *\/$/;"	m	class:Technology
capPmosDrain	ReadCircuit.h	/^	double capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain, capPmosGate, capPmosDrain, capInvInput, capInvOutput;$/;"	m	class:ReadCircuit
capPmosDrain	VoltageSenseAmp.h	/^	double capNmosGate, capNmosDrain, capPmosGate, capPmosDrain;$/;"	m	class:VoltageSenseAmp
capPmosGate	ReadCircuit.h	/^	double capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain, capPmosGate, capPmosDrain, capInvInput, capInvOutput;$/;"	m	class:ReadCircuit
capPmosGate	VoltageSenseAmp.h	/^	double capNmosGate, capNmosDrain, capPmosGate, capPmosDrain;$/;"	m	class:VoltageSenseAmp
capPolywire	Technology.h	/^	double capPolywire;	\/* Poly wire capacitance, Unit: F\/m *\/$/;"	m	class:Technology
capRow1	SubArray.h	/^	double capRow1;		\/\/ Capacitance of row1 (BL for 1T1R, WL for Cross-point), Unit: F$/;"	m	class:SubArray
capRow2	SubArray.h	/^	double capRow2;		\/\/ Capacitance of row2 (WL for 1T1R), Unit: F$/;"	m	class:SubArray
capS1	VoltageSenseAmp.h	/^	double capS1;$/;"	m	class:VoltageSenseAmp
capSRAMCell	LUT.h	/^	double capSRAMCell, capLoad;$/;"	m	class:LUT
capSRAMCell	MemCell.h	/^	double capSRAMCell;$/;"	m	class:MemCell
capSidewall	Technology.h	/^	double capSidewall;		\/* Junction sidewall capacitance, Cjsw, Unit: F\/m *\/$/;"	m	class:Technology
capTgDrain	DFF.h	/^	double capTgDrain, capTgGateN, capTgGateP, capInvInput, capInvOutput;$/;"	m	class:DFF
capTgDrain	DeMux.h	/^	double capInvInput, capInvOutput, capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:DeMux
capTgDrain	DecoderDriver.h	/^	double capInvInput, capInvOutput, capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:DecoderDriver
capTgDrain	Mux.h	/^	double capNandInput, capNandOutput, capEnInvInput, capEnInvOutput, capMuxInvInput, capMuxInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:Mux
capTgDrain	NewSwitchMatrix.h	/^	double capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:NewSwitchMatrix
capTgDrain	ReadCircuit.h	/^	double capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain, capPmosGate, capPmosDrain, capInvInput, capInvOutput;$/;"	m	class:ReadCircuit
capTgDrain	SwitchMatrix.h	/^	double capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:SwitchMatrix
capTgDrain	WLDecoderOutput.h	/^	double capNorInput, capNorOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain;$/;"	m	class:WLDecoderOutput
capTgDrain	WLNewDecoderDriver.h	/^	double capNandInput, capNandOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:WLNewDecoderDriver
capTgGateN	DFF.h	/^	double capTgDrain, capTgGateN, capTgGateP, capInvInput, capInvOutput;$/;"	m	class:DFF
capTgGateN	DeMux.h	/^	double capInvInput, capInvOutput, capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:DeMux
capTgGateN	DecoderDriver.h	/^	double capInvInput, capInvOutput, capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:DecoderDriver
capTgGateN	Mux.h	/^	double capNandInput, capNandOutput, capEnInvInput, capEnInvOutput, capMuxInvInput, capMuxInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:Mux
capTgGateN	NewSwitchMatrix.h	/^	double capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:NewSwitchMatrix
capTgGateN	ReadCircuit.h	/^	double capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain, capPmosGate, capPmosDrain, capInvInput, capInvOutput;$/;"	m	class:ReadCircuit
capTgGateN	SwitchMatrix.h	/^	double capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:SwitchMatrix
capTgGateN	WLDecoderOutput.h	/^	double capNorInput, capNorOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain;$/;"	m	class:WLDecoderOutput
capTgGateN	WLNewDecoderDriver.h	/^	double capNandInput, capNandOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:WLNewDecoderDriver
capTgGateP	DFF.h	/^	double capTgDrain, capTgGateN, capTgGateP, capInvInput, capInvOutput;$/;"	m	class:DFF
capTgGateP	DeMux.h	/^	double capInvInput, capInvOutput, capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:DeMux
capTgGateP	DecoderDriver.h	/^	double capInvInput, capInvOutput, capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:DecoderDriver
capTgGateP	Mux.h	/^	double capNandInput, capNandOutput, capEnInvInput, capEnInvOutput, capMuxInvInput, capMuxInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:Mux
capTgGateP	NewSwitchMatrix.h	/^	double capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:NewSwitchMatrix
capTgGateP	ReadCircuit.h	/^	double capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain, capPmosGate, capPmosDrain, capInvInput, capInvOutput;$/;"	m	class:ReadCircuit
capTgGateP	SwitchMatrix.h	/^	double capTgDrain, capTgGateN, capTgGateP;$/;"	m	class:SwitchMatrix
capTgGateP	WLDecoderOutput.h	/^	double capNorInput, capNorOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain, capNmosGate, capNmosDrain;$/;"	m	class:WLDecoderOutput
capTgGateP	WLNewDecoderDriver.h	/^	double capNandInput, capNandOutput, capInvInput, capInvOutput, capTgGateN, capTgGateP, capTgDrain;$/;"	m	class:WLNewDecoderDriver
capWireLoadPerColumn	Precharger.h	/^	double capWireLoadPerColumn, resWireLoadPerColumn;$/;"	m	class:Precharger
cast	HWsim_wrap.cxx	/^  struct swig_cast_info  *cast;			\/* linked list of types that can cast into this type *\/$/;"	m	struct:swig_type_info	typeref:struct:swig_type_info::swig_cast_info	file:
cast_initial	HWsim_wrap.cxx	/^  swig_cast_info         **cast_initial;	\/* Array of initially generated casting structures *\/$/;"	m	struct:swig_module_info	file:
cell	ActivationFunc.h	/^	const MemCell& cell;$/;"	m	class:ActivationFunc
cell	Adder.h	/^	const MemCell& cell;$/;"	m	class:Adder
cell	Comparator.h	/^	const MemCell& cell;$/;"	m	class:Comparator
cell	Core.h	/^	const MemCell& cell;$/;"	m	class:Core
cell	CurrentSenseAmp.h	/^	const MemCell& cell;$/;"	m	class:CurrentSenseAmp
cell	DFF.h	/^	const MemCell& cell;$/;"	m	class:DFF
cell	DeMux.h	/^	const MemCell& cell;$/;"	m	class:DeMux
cell	DecoderDriver.h	/^	const MemCell& cell;$/;"	m	class:DecoderDriver
cell	HWsim.h	/^	MemCell cell;$/;"	m	class:HWsim
cell	LUT.h	/^	const MemCell& cell;$/;"	m	class:LUT
cell	MultilevelSAEncoder.h	/^	const MemCell& cell;$/;"	m	class:MultilevelSAEncoder
cell	MultilevelSenseAmp.h	/^	const MemCell& cell;$/;"	m	class:MultilevelSenseAmp
cell	Mux.h	/^	const MemCell& cell;$/;"	m	class:Mux
cell	NewSwitchMatrix.h	/^	const MemCell& cell;$/;"	m	class:NewSwitchMatrix
cell	Precharger.h	/^	const MemCell& cell;$/;"	m	class:Precharger
cell	ReadCircuit.h	/^	const MemCell& cell;$/;"	m	class:ReadCircuit
cell	RippleCounter.h	/^	const MemCell& cell;$/;"	m	class:RippleCounter
cell	RowDecoder.h	/^	const MemCell& cell;$/;"	m	class:RowDecoder
cell	SRAMWriteDriver.h	/^	const MemCell& cell;$/;"	m	class:SRAMWriteDriver
cell	SenseAmp.h	/^	const MemCell& cell;$/;"	m	class:SenseAmp
cell	ShiftAdd.h	/^	const MemCell& cell;$/;"	m	class:ShiftAdd
cell	SubArray.h	/^	MemCell& cell;$/;"	m	class:SubArray
cell	Sum.h	/^	const MemCell& cell;$/;"	m	class:Sum
cell	SwitchMatrix.h	/^	const MemCell& cell;$/;"	m	class:SwitchMatrix
cell	VoltageSenseAmp.h	/^	const MemCell& cell;$/;"	m	class:VoltageSenseAmp
cell	WLDecoderOutput.h	/^	const MemCell& cell;$/;"	m	class:WLDecoderOutput
cell	WLNewDecoderDriver.h	/^	const MemCell& cell;$/;"	m	class:WLNewDecoderDriver
cell	tmp/test/test_core.cpp	/^MemCell cell;$/;"	v
cellbit	tmp/ParameterData.h	/^	int cellbit;                                       \/\/ # of bits of each RRAM cell$/;"	m	class:ParameterData
cellrange	tmp/ParameterData.h	/^	int cellrange;                       \/\/ the value range of each RRAM cell$/;"	m	class:ParameterData
charbufferproc	HWsim_wrap.cxx	/^typedef getcharbufferproc charbufferproc;$/;"	t	file:
clientdata	HWsim_wrap.cxx	/^  void                    *clientdata;		\/* Language specific module data *\/$/;"	m	struct:swig_module_info	file:
clientdata	HWsim_wrap.cxx	/^  void                   *clientdata;		\/* language specific type data *\/$/;"	m	struct:swig_type_info	file:
clkFreq	CurrentSenseAmp.h	/^	double clkFreq;$/;"	m	class:CurrentSenseAmp
clkFreq	DFF.h	/^	double clkFreq;$/;"	m	class:DFF
clkFreq	LUT.h	/^	double clkFreq;$/;"	m	class:LUT
clkFreq	MultilevelSenseAmp.h	/^	double clkFreq;$/;"	m	class:MultilevelSenseAmp
clkFreq	NewSwitchMatrix.h	/^	double clkFreq;$/;"	m	class:NewSwitchMatrix
clkFreq	ReadCircuit.h	/^	double clkFreq;$/;"	m	class:ReadCircuit
clkFreq	ReadParam.h	/^	double clkFreq;					\/* Clock frequence, Unit: Hz *\/$/;"	m	class:ReadParam
clkFreq	RippleCounter.h	/^	double clkFreq;$/;"	m	class:RippleCounter
clkFreq	SenseAmp.h	/^	double clkFreq;$/;"	m	class:SenseAmp
clkFreq	ShiftAdd.h	/^	double clkFreq;$/;"	m	class:ShiftAdd
clkFreq	SubArray.h	/^	double clkFreq;			\/\/ Clock frequency (Hz)$/;"	m	class:SubArray
clkFreq	SwitchMatrix.h	/^	double clkFreq;$/;"	m	class:SwitchMatrix
clkFreq	VoltageSenseAmp.h	/^	double clkFreq;$/;"	m	class:VoltageSenseAmp
colDecoder	LUT.h	/^	RowDecoder colDecoder;$/;"	m	class:LUT
colDecoder	SubArray.h	/^	RowDecoder colDecoder;$/;"	m	class:SubArray
colDecoderDriver	LUT.h	/^	DecoderDriver colDecoderDriver;$/;"	m	class:LUT
colDecoderDriver	SubArray.h	/^	DecoderDriver colDecoderDriver;$/;"	m	class:SubArray
colDelay	SubArray.h	/^	double colDelay;	\/\/ Column delay, Unit: s$/;"	m	class:SubArray
comparator	SubArray.h	/^	Comparator comparator;$/;"	m	class:SubArray
conventional	typedef.h	/^	conventional,	\/* conventional CMOS *\/$/;"	e	enum:TransistorType
converter	HWsim_wrap.cxx	/^  swig_converter_func     converter;		\/* function to cast the void pointers *\/$/;"	m	struct:swig_cast_info	file:
core	HWsim.h	/^	Core* core;$/;"	m	class:HWsim
curr	tmp/addstring.py	/^                    curr = lines[0:line-3]$/;"	v
curr	tmp/addstring.py	/^        curr = None$/;"	v
curr	tmp/addstring2.py	/^                    curr = lines[0:line]$/;"	v
curr	tmp/addstring2.py	/^        curr = None$/;"	v
curr2	tmp/addstring2.py	/^                    curr2 = lines[line+1:]$/;"	v
currentOffNmos	Technology.h	/^	double currentOffNmos[101];	\/* NMOS off current (from 300K to 400K), Unit: A\/m *\/$/;"	m	class:Technology
currentOffPmos	Technology.h	/^	double currentOffPmos[101]; \/* PMOS off current (from 300K to 400K), Unit: A\/m *\/$/;"	m	class:Technology
currentOnNmos	Technology.h	/^	double currentOnNmos[101];		\/* NMOS saturation current, Unit: A\/m *\/$/;"	m	class:Technology
currentOnPmos	Technology.h	/^	double currentOnPmos[101];		\/* PMOS saturation current, Unit: A\/m *\/$/;"	m	class:Technology
currentSense	SenseAmp.h	/^	bool currentSense;		\/* Whether the sensing scheme is current-based *\/$/;"	m	class:SenseAmp
currentSenseAmp	MultilevelSenseAmp.h	/^	CurrentSenseAmp currentSenseAmp;$/;"	m	class:MultilevelSenseAmp
current_gmNmos	Technology.h	/^    double current_gmNmos;		\/* NMOS current at 0.7*vdd for gm calculation, Unit: A\/m\/V*\/ $/;"	m	class:Technology
current_gmPmos	Technology.h	/^    double current_gmPmos;		\/* PMOS current at 0.7*vdd for gm calculation, Unit: A\/m\/V*\/ $/;"	m	class:Technology
dcast	HWsim_wrap.cxx	/^  swig_dycast_func        dcast;		\/* dynamic cast function down a hierarchy *\/$/;"	m	struct:swig_type_info	file:
deMux	SubArray.h	/^	DeMux   deMux;$/;"	m	class:SubArray
delargs	HWsim_wrap.cxx	/^  int delargs;$/;"	m	struct:__anon2	file:
description	setup.py	/^        description = "HWsim",$/;"	v
designopt	ReadParam.h	/^	DesignOptimization designopt;	\/* Either read latency, write latency, read energy, write energy, leakage, or area *\/$/;"	m	class:ReadParam
designoptname	ReadParam.h	/^	std::string designoptname;$/;"	m	class:ReadParam
destroy	HWsim_wrap.cxx	/^  PyObject *destroy;$/;"	m	struct:__anon2	file:
deviceRoadmap	InputParameter.h	/^	DeviceRoadmap deviceRoadmap;	\/* ITRS roadmap: HP or LSTP *\/$/;"	m	class:InputParameter
deviceRoadmap	ReadParam.h	/^	DeviceRoadmap deviceRoadmap;	\/* ITRS roadmap: HP, LSTP *\/$/;"	m	class:ReadParam
deviceRoadmap	Technology.h	/^	DeviceRoadmap deviceRoadmap;	\/* HP or LP *\/$/;"	m	class:Technology
dff	NewSwitchMatrix.h	/^	DFF dff;$/;"	m	class:NewSwitchMatrix
dff	RippleCounter.h	/^	DFF dff;$/;"	m	class:RippleCounter
dff	ShiftAdd.h	/^	DFF dff;$/;"	m	class:ShiftAdd
dff	SubArray.h	/^	DFF dff;$/;"	m	class:SubArray
dff	SwitchMatrix.h	/^	DFF dff;$/;"	m	class:SwitchMatrix
dict	HWsim_wrap.cxx	/^  PyObject *dict;$/;"	m	struct:__anon3	file:
digitalModeNeuro	SubArray.h	/^	bool digitalModeNeuro;	\/\/ Digital RRAM in neuro mode$/;"	m	class:SubArray
diode_access	typedef.h	/^	diode_access,$/;"	e	enum:CellAccessType
dvalue	HWsim_wrap.cxx	/^  double dvalue;$/;"	m	struct:swig_const_info	file:
effectiveResistanceMultiplier	Technology.h	/^	double effectiveResistanceMultiplier;	\/* Extra resistance due to vdsat *\/$/;"	m	class:Technology
emptyArea	FunctionUnit.h	/^	double emptyArea;		\/* Unit: m^2 *\/$/;"	m	class:FunctionUnit
enableLatency	Precharger.h	/^	double enableLatency;$/;"	m	class:Precharger
end	HWsim_wrap.cxx	/^         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}$/;"	f	class:SWIG_Python_Thread_Allow
end	HWsim_wrap.cxx	/^         void end() { if (status) { PyGILState_Release(state); status = false;} }$/;"	f	class:SWIG_Python_Thread_Block
ext_modules	setup.py	/^        ext_modules = [pht_module],$/;"	v
featureSize	MemCell.h	/^	double featureSize;$/;"	m	class:MemCell
featureSize	Technology.h	/^	double featureSize;	\/* Process feature size, Unit: m *\/$/;"	m	class:Technology
featureSizeInNano	Technology.h	/^	int featureSizeInNano; \/*Process feature size, Unit: nm *\/$/;"	m	class:Technology
fileCellType	ReadParam.h	/^	std::string fileCellType;		\/* Input file name of cell type: DigitalRRAMTHU *\/$/;"	m	class:ReadParam
freefunc	HWsim_wrap.cxx	/^typedef destructor freefunc;$/;"	t	file:
get_attr	HWsim_wrap.cxx	/^    PyObject *(*get_attr)(void);       \/* Return the current value *\/$/;"	m	struct:swig_globalvar	file:
hAdder	Adder.h	/^	double hAdder, wAdder;$/;"	m	class:Adder
hDff	ReadCircuit.h	/^	double areaUnit, hUnit, wUnit, areaReadBody, hReadBody, wReadBody, areaDff, hDff, wDff;$/;"	m	class:ReadCircuit
hInv	ActivationFunc.h	/^	double wInv, hInv;$/;"	m	class:ActivationFunc
hNand	ActivationFunc.h	/^	double wNand, hNand;$/;"	m	class:ActivationFunc
hNmosL	CurrentSenseAmp.h	/^	double hNmosL, wNmosL, hNmosS, wNmosS, hNmosM, wNmosM;$/;"	m	class:CurrentSenseAmp
hNmosM	CurrentSenseAmp.h	/^	double hNmosL, wNmosL, hNmosS, wNmosS, hNmosM, wNmosM;$/;"	m	class:CurrentSenseAmp
hNmosS	CurrentSenseAmp.h	/^	double hNmosL, wNmosL, hNmosS, wNmosS, hNmosM, wNmosM;$/;"	m	class:CurrentSenseAmp
hReadBody	ReadCircuit.h	/^	double areaUnit, hUnit, wUnit, areaReadBody, hReadBody, wReadBody, areaDff, hDff, wDff;$/;"	m	class:ReadCircuit
hUnit	ReadCircuit.h	/^	double areaUnit, hUnit, wUnit, areaReadBody, hReadBody, wReadBody, areaDff, hDff, wDff;$/;"	m	class:ReadCircuit
height	FunctionUnit.h	/^	double height;		\/* Unit: m *\/$/;"	m	class:FunctionUnit
heightArray	SubArray.h	/^	double heightArray;$/;"	m	class:SubArray
heightFin	Technology.h	/^	double heightFin;	\/* Fin height, Unit: m *\/$/;"	m	class:Technology
heightInFeatureSize	MemCell.h	/^	double heightInFeatureSize;	\/* Cell height, Unit: F *\/$/;"	m	class:MemCell
horowitz	formula.cpp	/^double horowitz(double tr, double beta, double rampInput, double *rampOutput) {$/;"	f
implicitconv	HWsim_wrap.cxx	/^  int implicitconv;$/;"	m	struct:__anon2	file:
initialized	ActivationFunc.h	/^	bool initialized;$/;"	m	class:ActivationFunc
initialized	Adder.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:Adder
initialized	Comparator.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:Comparator
initialized	Core.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:Core
initialized	CurrentSenseAmp.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:CurrentSenseAmp
initialized	DFF.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:DFF
initialized	DeMux.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:DeMux
initialized	DecoderDriver.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:DecoderDriver
initialized	HWsim.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:HWsim
initialized	LUT.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:LUT
initialized	MultilevelSAEncoder.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:MultilevelSAEncoder
initialized	MultilevelSenseAmp.h	/^	bool initialized;		\/* Initialization flag *\/$/;"	m	class:MultilevelSenseAmp
initialized	Mux.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:Mux
initialized	NewSwitchMatrix.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:NewSwitchMatrix
initialized	Precharger.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:Precharger
initialized	ReadCircuit.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:ReadCircuit
initialized	RippleCounter.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:RippleCounter
initialized	RowDecoder.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:RowDecoder
initialized	SRAMWriteDriver.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:SRAMWriteDriver
initialized	SenseAmp.h	/^	bool initialized;		\/* Initialization flag *\/$/;"	m	class:SenseAmp
initialized	ShiftAdd.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:ShiftAdd
initialized	SubArray.h	/^	bool initialized;	\/\/ Initialization flag$/;"	m	class:SubArray
initialized	Sum.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:Sum
initialized	SwitchMatrix.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:SwitchMatrix
initialized	Technology.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:Technology
initialized	VoltageSenseAmp.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:VoltageSenseAmp
initialized	WLDecoderOutput.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:WLDecoderOutput
initialized	WLNewDecoderDriver.h	/^	bool initialized;	\/* Initialization flag *\/$/;"	m	class:WLNewDecoderDriver
inputParameter	ActivationFunc.h	/^	const InputParameter& inputParameter;$/;"	m	class:ActivationFunc
inputParameter	Adder.h	/^	const InputParameter& inputParameter;$/;"	m	class:Adder
inputParameter	Comparator.h	/^	const InputParameter& inputParameter;$/;"	m	class:Comparator
inputParameter	Core.h	/^	const InputParameter& inputParameter;$/;"	m	class:Core
inputParameter	CurrentSenseAmp.h	/^	const InputParameter& inputParameter;$/;"	m	class:CurrentSenseAmp
inputParameter	DFF.h	/^	const InputParameter& inputParameter;$/;"	m	class:DFF
inputParameter	DeMux.h	/^	const InputParameter& inputParameter;$/;"	m	class:DeMux
inputParameter	DecoderDriver.h	/^	const InputParameter& inputParameter;$/;"	m	class:DecoderDriver
inputParameter	HWsim.h	/^	InputParameter inputParameter;$/;"	m	class:HWsim
inputParameter	LUT.h	/^	const InputParameter& inputParameter;$/;"	m	class:LUT
inputParameter	MultilevelSAEncoder.h	/^	const InputParameter& inputParameter;$/;"	m	class:MultilevelSAEncoder
inputParameter	MultilevelSenseAmp.h	/^	const InputParameter& inputParameter;$/;"	m	class:MultilevelSenseAmp
inputParameter	Mux.h	/^	const InputParameter& inputParameter;$/;"	m	class:Mux
inputParameter	NewSwitchMatrix.h	/^	const InputParameter& inputParameter;$/;"	m	class:NewSwitchMatrix
inputParameter	Precharger.h	/^	const InputParameter& inputParameter;$/;"	m	class:Precharger
inputParameter	ReadCircuit.h	/^	const InputParameter& inputParameter;$/;"	m	class:ReadCircuit
inputParameter	RippleCounter.h	/^	const InputParameter& inputParameter;$/;"	m	class:RippleCounter
inputParameter	RowDecoder.h	/^	const InputParameter& inputParameter;$/;"	m	class:RowDecoder
inputParameter	SRAMWriteDriver.h	/^	const InputParameter& inputParameter;$/;"	m	class:SRAMWriteDriver
inputParameter	SenseAmp.h	/^	const InputParameter& inputParameter;$/;"	m	class:SenseAmp
inputParameter	ShiftAdd.h	/^	const InputParameter& inputParameter;$/;"	m	class:ShiftAdd
inputParameter	SubArray.h	/^	InputParameter& inputParameter;$/;"	m	class:SubArray
inputParameter	Sum.h	/^	const InputParameter& inputParameter;$/;"	m	class:Sum
inputParameter	SwitchMatrix.h	/^	const InputParameter& inputParameter;$/;"	m	class:SwitchMatrix
inputParameter	VoltageSenseAmp.h	/^	const InputParameter& inputParameter;$/;"	m	class:VoltageSenseAmp
inputParameter	WLDecoderOutput.h	/^	const InputParameter& inputParameter;$/;"	m	class:WLDecoderOutput
inputParameter	WLNewDecoderDriver.h	/^	const InputParameter& inputParameter;$/;"	m	class:WLNewDecoderDriver
inputParameter	tmp/test/test_core.cpp	/^InputParameter inputParameter;$/;"	v
interdff	SubArray.h	/^	DFF  interdff;$/;"	m	class:SubArray
intermux	SubArray.h	/^	Mux  intermux;$/;"	m	class:SubArray
intermuxDecoder	SubArray.h	/^	RowDecoder  intermuxDecoder;$/;"	m	class:SubArray
invalid	CurrentSenseAmp.h	/^	bool invalid;		\/* Indicate that the current configuration is not valid *\/$/;"	m	class:CurrentSenseAmp
invalid	WLNewDecoderDriver.h	/^	bool invalid;      \/*Invalidatio flag *\/$/;"	m	class:WLNewDecoderDriver
klass	HWsim_wrap.cxx	/^  PyObject *klass;$/;"	m	struct:__anon2	file:
layoutWidth	ShiftAdd.h	/^	double layoutWidth;$/;"	m	class:ShiftAdd
leakage	FunctionUnit.h	/^	double leakage;		\/* Unit: W *\/$/;"	m	class:FunctionUnit
lenfunc	HWsim_wrap.cxx	/^typedef inquiry lenfunc;$/;"	t	file:
lengthCol	SubArray.h	/^	double lengthCol;	\/\/ Length of columns, Unit: m$/;"	m	class:SubArray
lengthRow	SubArray.h	/^	double lengthRow;	\/\/ Length of rows, Unit: m$/;"	m	class:SubArray
levelOutput	MultilevelSenseAmp.h	/^    int levelOutput;$/;"	m	class:MultilevelSenseAmp
levelOutput	SubArray.h	/^	int levelOutput;$/;"	m	class:SubArray
lines	tmp/addstring.py	/^            lines = f.readlines()$/;"	v
lines	tmp/addstring2.py	/^            lines = f.readlines()$/;"	v
lvalue	HWsim_wrap.cxx	/^  long lvalue;$/;"	m	struct:swig_const_info	file:
main	HWsimMain.cpp	/^int main()$/;"	f
main	HWsim_test.cpp	/^int main()$/;"	f
main	tmp/test/test_HWsim.cpp	/^int main()$/;"	f
main	tmp/test/test_core.cpp	/^int main()$/;"	f
maxNumIntBit	ReadCircuit.h	/^	int maxNumIntBit;$/;"	m	class:ReadCircuit
maxNumIntBit	SubArray.h	/^	int maxNumIntBit;		\/\/ Max # bits for the integrate-and-fire neuron$/;"	m	class:SubArray
maxNumIntPerCycle	ReadCircuit.h	/^	double maxNumIntPerCycle;$/;"	m	class:ReadCircuit
maxNumWritePulse	SubArray.h	/^	int maxNumWritePulse;	\/\/ Max # of write pulses for the device$/;"	m	class:SubArray
memCellType	MemCell.h	/^	Type::MemCellType memCellType;	\/* Memory cell type (like MRAM, PCRAM, etc.) *\/$/;"	m	class:MemCell
minDriverCurrent	Mux.h	/^	double minDriverCurrent;$/;"	m	class:Mux
minSenseVoltage	MemCell.h	/^	double minSenseVoltage; \/* Minimum sense voltage *\/$/;"	m	class:MemCell
mode	DecoderDriver.h	/^	int mode;$/;"	m	class:DecoderDriver
mode	NewSwitchMatrix.h	/^	int mode;$/;"	m	class:NewSwitchMatrix
mode	ReadCircuit.h	/^	ReadCircuitMode mode;$/;"	m	class:ReadCircuit
mode	RowDecoder.h	/^	DecoderMode mode;	\/\/ ROW or COLUMN mode$/;"	m	class:RowDecoder
mode	SwitchMatrix.h	/^	int mode;$/;"	m	class:SwitchMatrix
multifunctional	SubArray.h	/^	bool multifunctional;	\/\/ Multifunctional memory$/;"	m	class:SubArray
multifunctional	WLDecoderOutput.h	/^	bool multifunctional;$/;"	m	class:WLDecoderOutput
multifunctional	WLNewDecoderDriver.h	/^	bool multifunctional;$/;"	m	class:WLNewDecoderDriver
multilevelSAEncoder	SubArray.h	/^	MultilevelSAEncoder multilevelSAEncoder;$/;"	m	class:SubArray
multilevelSenseAmp	SubArray.h	/^	MultilevelSenseAmp multilevelSenseAmp;$/;"	m	class:SubArray
multipleCells	MemCell.h	/^	int multipleCells;	\/* Use multiple cells as one weight element to reduce the variation (only layout now) *\/$/;"	m	class:MemCell
multipleCells	ReadParam.h	/^	int multipleCells;				\/* Using multiple cells as 1 cell *\/$/;"	m	class:ReadParam
mux	LUT.h	/^	Mux mux;$/;"	m	class:LUT
mux	SubArray.h	/^	Mux     mux;$/;"	m	class:SubArray
muxDecoder	LUT.h	/^	RowDecoder muxDecoder;$/;"	m	class:LUT
muxDecoder	SubArray.h	/^	RowDecoder  muxDecoder;$/;"	m	class:SubArray
name	HWsim_wrap.cxx	/^    char       *name;                  \/* Name of global variable *\/$/;"	m	struct:swig_globalvar	file:
name	HWsim_wrap.cxx	/^  PyObject *name, *slots;$/;"	m	struct:__anon1	file:
name	HWsim_wrap.cxx	/^  char *name;$/;"	m	struct:swig_const_info	file:
name	HWsim_wrap.cxx	/^  const char             *name;			\/* mangled name of this type *\/$/;"	m	struct:swig_type_info	file:
neuro	MultilevelSenseAmp.h	/^	bool neuro;$/;"	m	class:MultilevelSenseAmp
neuro	NewSwitchMatrix.h	/^	bool neuro;$/;"	m	class:NewSwitchMatrix
neuro	Precharger.h	/^	bool neuro;$/;"	m	class:Precharger
neuro	SRAMWriteDriver.h	/^	bool neuro;$/;"	m	class:SRAMWriteDriver
neuro	SenseAmp.h	/^	bool neuro;$/;"	m	class:SenseAmp
neuro	SubArray.h	/^	bool neuro;				\/\/ Neuro mode$/;"	m	class:SubArray
neuro	SwitchMatrix.h	/^	bool neuro;$/;"	m	class:SwitchMatrix
neuro	WLDecoderOutput.h	/^	bool neuro;$/;"	m	class:WLDecoderOutput
neuro	WLNewDecoderDriver.h	/^	bool neuro;$/;"	m	class:WLNewDecoderDriver
newBNNparallelMode	SubArray.h	/^	bool newBNNparallelMode;      \/\/ new pseudo-1T1R BNN parallel mode$/;"	m	class:SubArray
newBNNrowbyrowMode	SubArray.h	/^	bool newBNNrowbyrowMode;      \/\/ new pseudo-1T1R BNN row-by-row mode$/;"	m	class:SubArray
newHeight	FunctionUnit.h	/^	double newWidth, newHeight;$/;"	m	class:FunctionUnit
newWidth	FunctionUnit.h	/^	double newWidth, newHeight;$/;"	m	class:FunctionUnit
newargs	HWsim_wrap.cxx	/^  PyObject *newargs;$/;"	m	struct:__anon2	file:
newraw	HWsim_wrap.cxx	/^  PyObject *newraw;$/;"	m	struct:__anon2	file:
next	HWsim_wrap.cxx	/^    struct swig_globalvar *next;$/;"	m	struct:swig_globalvar	typeref:struct:swig_globalvar::swig_globalvar	file:
next	HWsim_wrap.cxx	/^  PyObject *next;$/;"	m	struct:__anon3	file:
next	HWsim_wrap.cxx	/^  struct swig_cast_info  *next;			\/* pointer to next cast in linked list *\/$/;"	m	struct:swig_cast_info	typeref:struct:swig_cast_info::swig_cast_info	file:
next	HWsim_wrap.cxx	/^  struct swig_module_info *next;		\/* Pointer to next element in circularly linked list *\/$/;"	m	struct:swig_module_info	typeref:struct:swig_module_info::swig_module_info	file:
none_access	typedef.h	/^	none_access$/;"	e	enum:CellAccessType
nonlinearIV	MemCell.h	/^	bool nonlinearIV;	\/* Consider I-V nonlinearity or not (Currently this option is for cross-point array. It is hard to have this option in pseudo-crossbar since it has an access transistor and the transistor's resistance can be comparable to RRAM's resistance after considering the nonlinearity. In this case, we have to iteratively find both the resistance and Vw across RRAM.) *\/$/;"	m	class:MemCell
nonlinearity	MemCell.h	/^	double nonlinearity;	\/* Current at write voltage \/ current at 1\/2 write voltage *\/$/;"	m	class:MemCell
numAdder	Adder.h	/^	int numAdder;$/;"	m	class:Adder
numAdder	ShiftAdd.h	/^	int numInv, numNand, numAdder, numDff;$/;"	m	class:ShiftAdd
numAdder	Sum.h	/^	int numAdder;		\/* Number of Adders in sum circuit *\/$/;"	m	class:Sum
numAdderBit	ShiftAdd.h	/^	int numAdderBit, numBitPerDff;$/;"	m	class:ShiftAdd
numAdderDepth	Sum.h	/^	int numAdderDepth;$/;"	m	class:Sum
numAddrRow	RowDecoder.h	/^	int numAddrRow;		\/* Number of rows *\/$/;"	m	class:RowDecoder
numArrayCol	Core.h	/^	int numArrayCol;			\/* Number of Array columns *\/$/;"	m	class:Core
numArrayCol	HWsim.h	/^	int numArrayCol;			\/* Number of Array columns *\/$/;"	m	class:HWsim
numArrayCol	ReadParam.h	/^	int numArrayCol;				\/* The Number of array columns *\/$/;"	m	class:ReadParam
numArrayRow	Core.h	/^	int numArrayRow;$/;"	m	class:Core
numArrayRow	HWsim.h	/^	int numArrayRow;$/;"	m	class:HWsim
numArrayRow	ReadParam.h	/^	int numArrayRow;				\/* The Number of array rows *\/$/;"	m	class:ReadParam
numBit	Adder.h	/^	int numBit;$/;"	m	class:Adder
numBit	Comparator.h	/^	int numBit;$/;"	m	class:Comparator
numBit	RippleCounter.h	/^	int numBit;$/;"	m	class:RippleCounter
numBitInput	Core.h	/^	int numBitInput;$/;"	m	class:Core
numBitInput	HWsim.h	/^	int numBitInput;$/;"	m	class:HWsim
numBitInput	tmp/test/test_core.cpp	/^int numBitInput = 8;$/;"	v
numBitPartialSum	Core.h	/^	int numBitPartialSum;		\/* The output bits of SA *\/$/;"	m	class:Core
numBitPartialSum	HWsim.h	/^	int numBitPartialSum;		\/* The output bits of SA *\/$/;"	m	class:HWsim
numBitPartialSum	tmp/test/test_core.cpp	/^int numBitPartialSum = 8;$/;"	v
numBitPerDff	ShiftAdd.h	/^	int numAdderBit, numBitPerDff;$/;"	m	class:ShiftAdd
numCMOS	MultilevelSenseAmp.h	/^	int numCMOS;$/;"	m	class:MultilevelSenseAmp
numCell	LUT.h	/^	int numCell;$/;"	m	class:LUT
numCellBit	Core.h	/^	int numCellBit;$/;"	m	class:Core
numCellBit	HWsim.h	/^	int numCellBit;$/;"	m	class:HWsim
numCellBit	tmp/test/test_core.cpp	/^int numCellBit = 2;$/;"	v
numCellPerSynapse	Core.h	/^	int numCellPerSynapse;\/* Number of cells per synapse *\/ $/;"	m	class:Core
numCellPerSynapse	HWsim.h	/^	int numCellPerSynapse;\/* Number of cells per synapse *\/ $/;"	m	class:HWsim
numCellPerSynapse	SubArray.h	/^	int numCellPerSynapse;  \/\/ Number of cells per synapse$/;"	m	class:SubArray
numCellPerSynapse	tmp/ParameterData.h	/^	int numCellPerSynapse;      \/\/ # of cells in one synapse$/;"	m	class:ParameterData
numCol	ActivationFunc.h	/^	int numCol;$/;"	m	class:ActivationFunc
numCol	CurrentSenseAmp.h	/^	int numCol;		\/* Number of columns *\/$/;"	m	class:CurrentSenseAmp
numCol	MultilevelSenseAmp.h	/^	int numCol;				\/* Number of columns *\/$/;"	m	class:MultilevelSenseAmp
numCol	Precharger.h	/^	int numCol;			\/* Number of columns *\/$/;"	m	class:Precharger
numCol	SRAMWriteDriver.h	/^	int numCol;			\/* Number of columns *\/$/;"	m	class:SRAMWriteDriver
numCol	SenseAmp.h	/^	int numCol;				\/* Number of columns *\/$/;"	m	class:SenseAmp
numCol	SubArray.h	/^	int numCol;			\/\/ Number of columns$/;"	m	class:SubArray
numCol	Sum.h	/^	int numCol;			\/* Number of Array columns *\/$/;"	m	class:Sum
numColInv	RowDecoder.h	/^	int numColNor, numNorPerCol, numColNand, numNandPerCol, numColInv, numInvPerCol;$/;"	m	class:RowDecoder
numColMuxed	SubArray.h	/^	int numColMuxed;	\/\/ How many columns share 1 read circuit (for neuro mode with analog RRAM) or 1 S\/A (for memory mode or neuro mode with digital RRAM)$/;"	m	class:SubArray
numColNand	RowDecoder.h	/^	int numColNor, numNorPerCol, numColNand, numNandPerCol, numColInv, numInvPerCol;$/;"	m	class:RowDecoder
numColNor	RowDecoder.h	/^	int numColNor, numNorPerCol, numColNand, numNandPerCol, numColInv, numInvPerCol;$/;"	m	class:RowDecoder
numColTg	DecoderDriver.h	/^	int numRowTg, numColTg;$/;"	m	class:DecoderDriver
numColTg	NewSwitchMatrix.h	/^	int numRowTg, numColTg;$/;"	m	class:NewSwitchMatrix
numColTgPair	SwitchMatrix.h	/^	int numRowTgPair, numColTgPair;$/;"	m	class:SwitchMatrix
numComparator	Comparator.h	/^	int numComparator;$/;"	m	class:Comparator
numDff	DFF.h	/^	int numDff;			\/* Number of columns *\/$/;"	m	class:DFF
numDff	ReadCircuit.h	/^	int numDff;$/;"	m	class:ReadCircuit
numDff	ShiftAdd.h	/^	int numInv, numNand, numAdder, numDff;$/;"	m	class:ShiftAdd
numEncoder	MultilevelSAEncoder.h	/^	int numEncoder;     \/\/ number of encoder needed$/;"	m	class:MultilevelSAEncoder
numEntry	LUT.h	/^	int numYbit, numEntry;$/;"	m	class:LUT
numGate	MultilevelSAEncoder.h	/^	int numGate;        \/\/ number of NAND gate in encoder $/;"	m	class:MultilevelSAEncoder
numIOBit	ActivationFunc.h	/^	int numIOBit;$/;"	m	class:ActivationFunc
numInput	DeMux.h	/^	int numInput;$/;"	m	class:DeMux
numInput	MultilevelSAEncoder.h	/^	int numInput;       \/\/ number of NAND gate in encoder$/;"	m	class:MultilevelSAEncoder
numInput	Mux.h	/^	int numInput;$/;"	m	class:Mux
numInv	RowDecoder.h	/^	int numInv, numNand, numNor, numMetalConnection;$/;"	m	class:RowDecoder
numInv	ShiftAdd.h	/^	int numInv, numNand, numAdder, numDff;$/;"	m	class:ShiftAdd
numInvPerCol	RowDecoder.h	/^	int numColNor, numNorPerCol, numColNand, numNandPerCol, numColInv, numInvPerCol;$/;"	m	class:RowDecoder
numInvPerRow	RowDecoder.h	/^	int numRowNor, numNorPerRow, numRowNand, numNandPerRow, numRowInv, numInvPerRow;$/;"	m	class:RowDecoder
numLevel	MultilevelSAEncoder.h	/^	int numLevel;       \/\/ number of levels from MultilevelSA$/;"	m	class:MultilevelSAEncoder
numLut	SubArray.h	/^	int numLut; \/\/ Parameter for FPGA$/;"	m	class:SubArray
numMetalConnection	RowDecoder.h	/^	int numInv, numNand, numNor, numMetalConnection;$/;"	m	class:RowDecoder
numNand	RowDecoder.h	/^	int numInv, numNand, numNor, numMetalConnection;$/;"	m	class:RowDecoder
numNand	ShiftAdd.h	/^	int numInv, numNand, numAdder, numDff;$/;"	m	class:ShiftAdd
numNandPerCol	RowDecoder.h	/^	int numColNor, numNorPerCol, numColNand, numNandPerCol, numColInv, numInvPerCol;$/;"	m	class:RowDecoder
numNandPerRow	RowDecoder.h	/^	int numRowNor, numNorPerRow, numRowNand, numNandPerRow, numRowInv, numInvPerRow;$/;"	m	class:RowDecoder
numNor	RowDecoder.h	/^	int numInv, numNand, numNor, numMetalConnection;$/;"	m	class:RowDecoder
numNorPerCol	RowDecoder.h	/^	int numColNor, numNorPerCol, numColNand, numNandPerCol, numColInv, numInvPerCol;$/;"	m	class:RowDecoder
numNorPerRow	RowDecoder.h	/^	int numRowNor, numNorPerRow, numRowNand, numNandPerRow, numRowInv, numInvPerRow;$/;"	m	class:RowDecoder
numOutput	Core.h	/^	int numOutput;		\/* Number of outputs *\/$/;"	m	class:Core
numOutput	DecoderDriver.h	/^	int numOutput;$/;"	m	class:DecoderDriver
numOutput	HWsim.h	/^	int numOutput;		\/* Number of outputs *\/$/;"	m	class:HWsim
numOutput	NewSwitchMatrix.h	/^	int numOutput;$/;"	m	class:NewSwitchMatrix
numOutput	Sum.h	/^	int numOutput;		\/* Number of outputs *\/$/;"	m	class:Sum
numOutput	SwitchMatrix.h	/^	int numOutput;$/;"	m	class:SwitchMatrix
numReadCellPerOperationFPGA	Precharger.h	/^	int numReadCellPerOperationFPGA;$/;"	m	class:Precharger
numReadCellPerOperationFPGA	SenseAmp.h	/^	int numReadCellPerOperationFPGA;$/;"	m	class:SenseAmp
numReadCellPerOperationFPGA	SubArray.h	/^	int numReadCellPerOperationFPGA;    \/\/ Parameter for SRAM$/;"	m	class:SubArray
numReadCellPerOperationMemory	Precharger.h	/^	int numReadCellPerOperationMemory;$/;"	m	class:Precharger
numReadCellPerOperationMemory	SenseAmp.h	/^	int numReadCellPerOperationMemory;$/;"	m	class:SenseAmp
numReadCellPerOperationMemory	SubArray.h	/^	int numReadCellPerOperationMemory;  \/\/ Parameter for SRAM$/;"	m	class:SubArray
numReadCellPerOperationNeuro	CurrentSenseAmp.h	/^	int numReadCellPerOperationNeuro;$/;"	m	class:CurrentSenseAmp
numReadCellPerOperationNeuro	MultilevelSenseAmp.h	/^	int numReadCellPerOperationNeuro;$/;"	m	class:MultilevelSenseAmp
numReadCellPerOperationNeuro	Precharger.h	/^	int numReadCellPerOperationNeuro;$/;"	m	class:Precharger
numReadCellPerOperationNeuro	SenseAmp.h	/^	int numReadCellPerOperationNeuro;$/;"	m	class:SenseAmp
numReadCellPerOperationNeuro	SubArray.h	/^	int numReadCellPerOperationNeuro;   \/\/ Parameter for SRAM (use numBitPerCell cells to represent one D)$/;"	m	class:SubArray
numReadCol	ReadCircuit.h	/^	int numReadCol;$/;"	m	class:ReadCircuit
numReadCol	VoltageSenseAmp.h	/^	int numReadCol;$/;"	m	class:VoltageSenseAmp
numReadLutPerOperationFPGA	SubArray.h	/^	int numReadLutPerOperationFPGA; \/\/ parameter for FPGA$/;"	m	class:SubArray
numReadPulse	ShiftAdd.h	/^	int numReadPulse;$/;"	m	class:ShiftAdd
numReadPulse	SubArray.h	/^	int numReadPulse;		\/\/ # of read pulses for the input vector$/;"	m	class:SubArray
numRow	SubArray.h	/^	int numRow;			\/\/ Number of rows$/;"	m	class:SubArray
numRowInv	RowDecoder.h	/^	int numRowNor, numNorPerRow, numRowNand, numNandPerRow, numRowInv, numInvPerRow;$/;"	m	class:RowDecoder
numRowNand	RowDecoder.h	/^	int numRowNor, numNorPerRow, numRowNand, numNandPerRow, numRowInv, numInvPerRow;$/;"	m	class:RowDecoder
numRowNor	RowDecoder.h	/^	int numRowNor, numNorPerRow, numRowNand, numNandPerRow, numRowInv, numInvPerRow;$/;"	m	class:RowDecoder
numRowTg	DecoderDriver.h	/^	int numRowTg, numColTg;$/;"	m	class:DecoderDriver
numRowTg	Mux.h	/^	int numRowTg;$/;"	m	class:Mux
numRowTg	NewSwitchMatrix.h	/^	int numRowTg, numColTg;$/;"	m	class:NewSwitchMatrix
numRowTgPair	SwitchMatrix.h	/^	int numRowTgPair, numColTgPair;$/;"	m	class:SwitchMatrix
numRowUnit	ReadCircuit.h	/^	int numUnitPerRow, numRowUnit;$/;"	m	class:ReadCircuit
numSABit	Core.h	/^	int numSABit;$/;"	m	class:Core
numSABit	HWsim.h	/^	int numSABit;$/;"	m	class:HWsim
numSelection	Mux.h	/^	int numSelection;		\/* Number of Selections *\/$/;"	m	class:Mux
numSum	Sum.h	/^	int numSum;\/* Number of cells per synapse *\/  $/;"	m	class:Sum
numSumBit	Sum.h	/^	int numSumBit;		\/* Number of bits of S\/A output *\/$/;"	m	class:Sum
numSumPerCol	Sum.h	/^	int numSumPerCol;	$/;"	m	class:Sum
numUnit	ShiftAdd.h	/^	int numUnit;$/;"	m	class:ShiftAdd
numUnitPerRow	ReadCircuit.h	/^	int numUnitPerRow, numRowUnit;$/;"	m	class:ReadCircuit
numWLRow	WLDecoderOutput.h	/^	int numWLRow;$/;"	m	class:WLDecoderOutput
numWLRow	WLNewDecoderDriver.h	/^	int numWLRow;$/;"	m	class:WLNewDecoderDriver
numWeightBit	Core.h	/^	int numWeightBit;$/;"	m	class:Core
numWeightBit	HWsim.h	/^	int numWeightBit;$/;"	m	class:HWsim
numWeightBit	tmp/test/test_core.cpp	/^int numWeightBit = 4;$/;"	v
numWriteCellPerOperationFPGA	Precharger.h	/^	int numWriteCellPerOperationFPGA;$/;"	m	class:Precharger
numWriteCellPerOperationFPGA	SRAMWriteDriver.h	/^	int numWriteCellPerOperationFPGA;$/;"	m	class:SRAMWriteDriver
numWriteCellPerOperationFPGA	SubArray.h	/^	int numWriteCellPerOperationFPGA;   \/\/ Parameter for SRAM$/;"	m	class:SubArray
numWriteCellPerOperationMemory	Precharger.h	/^	int numWriteCellPerOperationMemory;$/;"	m	class:Precharger
numWriteCellPerOperationMemory	SRAMWriteDriver.h	/^	int numWriteCellPerOperationMemory;$/;"	m	class:SRAMWriteDriver
numWriteCellPerOperationMemory	SubArray.h	/^	int numWriteCellPerOperationMemory;$/;"	m	class:SubArray
numWriteCellPerOperationMemory	SwitchMatrix.h	/^	int numWriteCellPerOperationMemory;$/;"	m	class:SwitchMatrix
numWriteCellPerOperationNeuro	NewSwitchMatrix.h	/^	int numWriteCellPerOperationNeuro;$/;"	m	class:NewSwitchMatrix
numWriteCellPerOperationNeuro	Precharger.h	/^	int numWriteCellPerOperationNeuro;$/;"	m	class:Precharger
numWriteCellPerOperationNeuro	SRAMWriteDriver.h	/^	int numWriteCellPerOperationNeuro;$/;"	m	class:SRAMWriteDriver
numWriteCellPerOperationNeuro	SubArray.h	/^	int numWriteCellPerOperationNeuro;  \/\/ For multifunctional mode or neuro only mode$/;"	m	class:SubArray
numWriteCellPerOperationNeuro	SwitchMatrix.h	/^	int numWriteCellPerOperationNeuro;$/;"	m	class:SwitchMatrix
numWriteColMuxed	SubArray.h	/^	int numWriteColMuxed;	\/\/ \/\/ How many columns share 1 write column decoder driver (for memory or neuro mode with digital RRAM)$/;"	m	class:SubArray
numWritePulse	NewSwitchMatrix.h	/^	double numWritePulse;$/;"	m	class:NewSwitchMatrix
numWritePulse	SubArray.h	/^	double numWritePulse;	\/\/ Average number of write pulse$/;"	m	class:SubArray
numWritePulse	SwitchMatrix.h	/^	double numWritePulse;$/;"	m	class:SwitchMatrix
numYbit	LUT.h	/^	int numYbit, numEntry;$/;"	m	class:LUT
numof1	SubArray.h	/^	double numof1, numof2, numof3, numof4, numof5, numof6, numof7, numof8, numof9, numof10;$/;"	m	class:SubArray
numof10	SubArray.h	/^	double numof1, numof2, numof3, numof4, numof5, numof6, numof7, numof8, numof9, numof10;$/;"	m	class:SubArray
numof2	SubArray.h	/^	double numof1, numof2, numof3, numof4, numof5, numof6, numof7, numof8, numof9, numof10;$/;"	m	class:SubArray
numof3	SubArray.h	/^	double numof1, numof2, numof3, numof4, numof5, numof6, numof7, numof8, numof9, numof10;$/;"	m	class:SubArray
numof4	SubArray.h	/^	double numof1, numof2, numof3, numof4, numof5, numof6, numof7, numof8, numof9, numof10;$/;"	m	class:SubArray
numof5	SubArray.h	/^	double numof1, numof2, numof3, numof4, numof5, numof6, numof7, numof8, numof9, numof10;$/;"	m	class:SubArray
numof6	SubArray.h	/^	double numof1, numof2, numof3, numof4, numof5, numof6, numof7, numof8, numof9, numof10;$/;"	m	class:SubArray
numof7	SubArray.h	/^	double numof1, numof2, numof3, numof4, numof5, numof6, numof7, numof8, numof9, numof10;$/;"	m	class:SubArray
numof8	SubArray.h	/^	double numof1, numof2, numof3, numof4, numof5, numof6, numof7, numof8, numof9, numof10;$/;"	m	class:SubArray
numof9	SubArray.h	/^	double numof1, numof2, numof3, numof4, numof5, numof6, numof7, numof8, numof9, numof10;$/;"	m	class:SubArray
operator &	HWsim_wrap.cxx	/^  T *operator&() { return pointer.ptr; }$/;"	f	class:SwigValueWrapper
operator ->	HWsim_wrap.cxx	/^    PyObject *operator->() const$/;"	f	class:swig::SwigPtr_PyObject
operator =	HWsim_wrap.cxx	/^    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }$/;"	f	struct:SwigValueWrapper::SwigMovePointer
operator =	HWsim_wrap.cxx	/^    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) $/;"	f	class:swig::SwigPtr_PyObject
operator =	HWsim_wrap.cxx	/^    SwigVar_PyObject & operator = (PyObject* obj)$/;"	f	struct:swig::SwigVar_PyObject
operator =	HWsim_wrap.cxx	/^  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }$/;"	f	class:SwigValueWrapper
operator PyObject *	HWsim_wrap.cxx	/^    operator PyObject *() const$/;"	f	class:swig::SwigPtr_PyObject
operator T&	HWsim_wrap.cxx	/^  operator T&() const { return *pointer.ptr; }$/;"	f	class:SwigValueWrapper
outputFilePrefix	ReadParam.h	/^	std::string outputFilePrefix;	\/* Output file name *\/$/;"	m	class:ReadParam
own	HWsim_wrap.cxx	/^  int own;$/;"	m	struct:__anon3	file:
owndata	HWsim_wrap.cxx	/^  int                    owndata;		\/* flag if the structure owns the clientdata *\/$/;"	m	struct:swig_type_info	file:
pack	HWsim_wrap.cxx	/^  void *pack;$/;"	m	struct:__anon4	file:
parallel	CurrentSenseAmp.h	/^	bool parallel;$/;"	m	class:CurrentSenseAmp
parallel	RowDecoder.h	/^	bool parallel;    \/\/ for mux decoder of parallel reading mode$/;"	m	class:RowDecoder
parallelCurrentSenseAmp	SubArray.h	/^	CurrentSenseAmp parallelCurrentSenseAmp;$/;"	m	class:SubArray
parallelWrite	NewSwitchMatrix.h	/^	bool parallelWrite;$/;"	m	class:NewSwitchMatrix
parallelWrite	SubArray.h	/^	bool parallelWrite; \/\/ Parameter for crossbar RRAM in neuro mode$/;"	m	class:SubArray
parallelWrite	SwitchMatrix.h	/^	bool parallelWrite;$/;"	m	class:SwitchMatrix
params	HWsim.h	/^	ReadParam params;$/;"	m	class:HWsim
pht_module	setup.py	/^pht_module = Extension("_HWsim",$/;"	v
phyGateLength	Technology.h	/^	double phyGateLength;	\/* Physical gate length, Unit: m *\/$/;"	m	class:Technology
pitchSenseAmp	SenseAmp.h	/^	double pitchSenseAmp;	\/* The maximum width allowed for one sense amplifier layout *\/$/;"	m	class:SenseAmp
pnSizeRatio	Technology.h	/^	double pnSizeRatio;		\/* PMOS to NMOS size ratio *\/$/;"	m	class:Technology
pointer	HWsim_wrap.cxx	/^  } pointer;$/;"	m	class:SwigValueWrapper	typeref:struct:SwigValueWrapper::SwigMovePointer	file:
precharger	SubArray.h	/^	Precharger precharger;$/;"	m	class:SubArray
prev	HWsim_wrap.cxx	/^  struct swig_cast_info  *prev;			\/* pointer to the previous cast *\/$/;"	m	struct:swig_cast_info	typeref:struct:swig_cast_info::swig_cast_info	file:
processNode	InputParameter.h	/^	int processNode;				\/* Process node (nm) *\/$/;"	m	class:InputParameter
processNode	MemCell.h	/^	int processNode;        \/* Cell original process technology node, Unit: nm*\/$/;"	m	class:MemCell
processNode	ReadParam.h	/^	int processNode;				\/* Process node (nm) *\/$/;"	m	class:ReadParam
ptr	HWsim_wrap.cxx	/^    T *ptr;$/;"	m	struct:SwigValueWrapper::SwigMovePointer	file:
ptr	HWsim_wrap.cxx	/^  void *ptr;$/;"	m	struct:__anon3	file:
ptype	HWsim_wrap.cxx	/^  swig_type_info **ptype;$/;"	m	struct:swig_const_info	file:
pvalue	HWsim_wrap.cxx	/^  void   *pvalue;$/;"	m	struct:swig_const_info	file:
py_modules	setup.py	/^        py_modules = ["HWsim"],$/;"	v
pytype	HWsim_wrap.cxx	/^  PyTypeObject *pytype;$/;"	m	struct:__anon2	file:
rampInput	ActivationFunc.h	/^	double rampInput;$/;"	m	class:ActivationFunc
rampInput	Adder.h	/^	double rampInput, rampOutput;$/;"	m	class:Adder
rampInput	Comparator.h	/^	double rampInput, rampOutput;$/;"	m	class:Comparator
rampInput	DFF.h	/^	double rampInput, rampOutput;$/;"	m	class:DFF
rampInput	DeMux.h	/^	double rampInput, rampOutput;$/;"	m	class:DeMux
rampInput	DecoderDriver.h	/^	double rampInput, rampOutput;$/;"	m	class:DecoderDriver
rampInput	LUT.h	/^	double rampInput, rampOutput;$/;"	m	class:LUT
rampInput	MultilevelSAEncoder.h	/^	double rampInput, rampOutput;$/;"	m	class:MultilevelSAEncoder
rampInput	Mux.h	/^	double rampInput, rampOutput;$/;"	m	class:Mux
rampInput	NewSwitchMatrix.h	/^	double rampInput, rampOutput;$/;"	m	class:NewSwitchMatrix
rampInput	Precharger.h	/^	double rampInput, rampOutput;$/;"	m	class:Precharger
rampInput	ReadCircuit.h	/^	double rampInput, rampOutput;$/;"	m	class:ReadCircuit
rampInput	RowDecoder.h	/^	double rampInput, rampOutput;$/;"	m	class:RowDecoder
rampInput	SRAMWriteDriver.h	/^	double rampInput, rampOutput;$/;"	m	class:SRAMWriteDriver
rampInput	ShiftAdd.h	/^	double rampInput, rampOutput;$/;"	m	class:ShiftAdd
rampInput	SwitchMatrix.h	/^	double rampInput, rampOutput;$/;"	m	class:SwitchMatrix
rampInput	VoltageSenseAmp.h	/^	double rampInput, rampOutput;$/;"	m	class:VoltageSenseAmp
rampInput	WLDecoderOutput.h	/^	double rampInput, rampOutput;$/;"	m	class:WLDecoderOutput
rampInput	WLNewDecoderDriver.h	/^	double rampInput, rampOutput;$/;"	m	class:WLNewDecoderDriver
rampOutput	Adder.h	/^	double rampInput, rampOutput;$/;"	m	class:Adder
rampOutput	Comparator.h	/^	double rampInput, rampOutput;$/;"	m	class:Comparator
rampOutput	DFF.h	/^	double rampInput, rampOutput;$/;"	m	class:DFF
rampOutput	DeMux.h	/^	double rampInput, rampOutput;$/;"	m	class:DeMux
rampOutput	DecoderDriver.h	/^	double rampInput, rampOutput;$/;"	m	class:DecoderDriver
rampOutput	LUT.h	/^	double rampInput, rampOutput;$/;"	m	class:LUT
rampOutput	MultilevelSAEncoder.h	/^	double rampInput, rampOutput;$/;"	m	class:MultilevelSAEncoder
rampOutput	Mux.h	/^	double rampInput, rampOutput;$/;"	m	class:Mux
rampOutput	NewSwitchMatrix.h	/^	double rampInput, rampOutput;$/;"	m	class:NewSwitchMatrix
rampOutput	Precharger.h	/^	double rampInput, rampOutput;$/;"	m	class:Precharger
rampOutput	ReadCircuit.h	/^	double rampInput, rampOutput;$/;"	m	class:ReadCircuit
rampOutput	RowDecoder.h	/^	double rampInput, rampOutput;$/;"	m	class:RowDecoder
rampOutput	SRAMWriteDriver.h	/^	double rampInput, rampOutput;$/;"	m	class:SRAMWriteDriver
rampOutput	ShiftAdd.h	/^	double rampInput, rampOutput;$/;"	m	class:ShiftAdd
rampOutput	SwitchMatrix.h	/^	double rampInput, rampOutput;$/;"	m	class:SwitchMatrix
rampOutput	VoltageSenseAmp.h	/^	double rampInput, rampOutput;$/;"	m	class:VoltageSenseAmp
rampOutput	WLDecoderOutput.h	/^	double rampInput, rampOutput;$/;"	m	class:WLDecoderOutput
rampOutput	WLNewDecoderDriver.h	/^	double rampInput, rampOutput;$/;"	m	class:WLNewDecoderDriver
readCircuit	SubArray.h	/^	ReadCircuit readCircuit;$/;"	m	class:SubArray
readCircuitMode	SubArray.h	/^	ReadCircuitMode readCircuitMode;$/;"	m	class:SubArray
readDynamicEnergy	FunctionUnit.h	/^	double readDynamicEnergy, writeDynamicEnergy;	\/* Unit: J *\/$/;"	m	class:FunctionUnit
readDynamicEnergyArray	SubArray.h	/^	double readDynamicEnergyArray, writeDynamicEnergyArray;$/;"	m	class:SubArray
readLatency	FunctionUnit.h	/^	double readLatency, writeLatency;		\/* Unit: s *\/$/;"	m	class:FunctionUnit
readNoise	tmp/ParameterData.h	/^	double readNoise;$/;"	m	class:ParameterData
readParam	ActivationFunc.h	/^	const ReadParam& readParam;$/;"	m	class:ActivationFunc
readParam	Core.h	/^	const ReadParam& readParam;$/;"	m	class:Core
readPower	FunctionUnit.h	/^	double readPower, writePower;$/;"	m	class:FunctionUnit
readPulseWidth	MemCell.h	/^	double readPulseWidth;$/;"	m	class:MemCell
readVoltage	MemCell.h	/^	double readVoltage;$/;"	m	class:MemCell
readbufferproc	HWsim_wrap.cxx	/^typedef getreadbufferproc readbufferproc;$/;"	t	file:
relaxArrayCellHeight	SubArray.h	/^	bool relaxArrayCellHeight;	\/\/ true: relax the memory cell height to match the height of periperal circuit unit that connects to the row (ex: standard cell height in the last stage of row decoder) if the latter is larger$/;"	m	class:SubArray
relaxArrayCellWidth	SubArray.h	/^	bool relaxArrayCellWidth;	\/\/ true: relax the memory cell width to match the width of periperal circuit unit that connects to the column (ex: pass gate width in the column mux) if the latter is larger$/;"	m	class:SubArray
resCellAccess	MemCell.h	/^	double resCellAccess;$/;"	m	class:MemCell
resCellAccess	SubArray.h	/^	double resCellAccess;	\/\/ Resistance of access device, Unit: ohm$/;"	m	class:SubArray
resCol	SubArray.h	/^	double resCol;		\/\/ Column resistance, Unit: ohm$/;"	m	class:SubArray
resLoad	DecoderDriver.h	/^	double resLoad;	\/* Output resistance, unit: ohm *\/$/;"	m	class:DecoderDriver
resLoad	NewSwitchMatrix.h	/^	double resLoad;$/;"	m	class:NewSwitchMatrix
resLoad	Precharger.h	/^	double capLoad, resLoad;$/;"	m	class:Precharger
resLoad	SRAMWriteDriver.h	/^	double capLoad, resLoad;$/;"	m	class:SRAMWriteDriver
resLoad	SwitchMatrix.h	/^	double resLoad;$/;"	m	class:SwitchMatrix
resLoad	WLDecoderOutput.h	/^	double resLoad;	\/* Output resistance, unit: ohm *\/$/;"	m	class:WLDecoderOutput
resLoad	WLNewDecoderDriver.h	/^	double resLoad;	\/* Output resistance, unit: ohm *\/$/;"	m	class:WLNewDecoderDriver
resMemCellAvg	MemCell.h	/^	double resMemCellAvg;	\/\/ At on-chip Vr (different than the Vr in the reported measurement data)$/;"	m	class:MemCell
resMemCellAvgAtHalfVw	MemCell.h	/^	double resMemCellAvgAtHalfVw;$/;"	m	class:MemCell
resMemCellAvgAtVw	MemCell.h	/^	double resMemCellAvgAtVw;$/;"	m	class:MemCell
resMemCellOff	MemCell.h	/^	double resMemCellOff;	\/\/ At on-chip Vr (different than the Vr in the reported measurement data)$/;"	m	class:MemCell
resMemCellOffAtHalfVw	MemCell.h	/^	double resMemCellOffAtHalfVw;$/;"	m	class:MemCell
resMemCellOffAtVw	MemCell.h	/^	double resMemCellOffAtVw;$/;"	m	class:MemCell
resMemCellOn	MemCell.h	/^	double resMemCellOn;	\/\/ At on-chip Vr (different than the Vr in the reported measurement data)$/;"	m	class:MemCell
resMemCellOnAtHalfVw	MemCell.h	/^	double resMemCellOnAtHalfVw;$/;"	m	class:MemCell
resMemCellOnAtVw	MemCell.h	/^	double resMemCellOnAtVw;$/;"	m	class:MemCell
resPrecharge	VoltageSenseAmp.h	/^	double resPrecharge;$/;"	m	class:VoltageSenseAmp
resRow	SubArray.h	/^	double resRow;		\/\/ Row resistance, Unit: ohm$/;"	m	class:SubArray
resTg	DeMux.h	/^	double resTg;$/;"	m	class:DeMux
resTg	DecoderDriver.h	/^	double resTg;$/;"	m	class:DecoderDriver
resTg	Mux.h	/^	double resTg;$/;"	m	class:Mux
resTg	NewSwitchMatrix.h	/^	double resTg;$/;"	m	class:NewSwitchMatrix
resTg	SwitchMatrix.h	/^	double resTg;$/;"	m	class:SwitchMatrix
resTg	WLDecoderOutput.h	/^	double resTg;$/;"	m	class:WLDecoderOutput
resTg	WLNewDecoderDriver.h	/^	double resTg;$/;"	m	class:WLNewDecoderDriver
resWireLoadPerColumn	Precharger.h	/^	double capWireLoadPerColumn, resWireLoadPerColumn;$/;"	m	class:Precharger
resistanceAvg	MemCell.h	/^	double resistanceAvg;$/;"	m	class:MemCell
resistanceOff	MemCell.h	/^	double resistanceOff;	\/* Turn-off resistance *\/$/;"	m	class:MemCell
resistanceOn	MemCell.h	/^	double resistanceOn;	\/* Turn-on resistance *\/$/;"	m	class:MemCell
rowCurrentSenseAmp	SubArray.h	/^	CurrentSenseAmp rowCurrentSenseAmp;$/;"	m	class:SubArray
rowbyrow	CurrentSenseAmp.h	/^	bool rowbyrow;$/;"	m	class:CurrentSenseAmp
save	HWsim_wrap.cxx	/^         PyThreadState *save;$/;"	m	class:SWIG_Python_Thread_Allow	file:
segcountproc	HWsim_wrap.cxx	/^typedef getsegcountproc segcountproc;$/;"	t	file:
senseAmp	SubArray.h	/^	SenseAmp senseAmp;$/;"	m	class:SubArray
senseVoltage	SenseAmp.h	/^	double senseVoltage;	\/* Minimum sensible voltage *\/$/;"	m	class:SenseAmp
set_attr	HWsim_wrap.cxx	/^    int       (*set_attr)(PyObject *); \/* Set the value *\/$/;"	m	struct:swig_globalvar	file:
shiftAdd	Core.h	/^	ShiftAdd shiftAdd;$/;"	m	class:Core
shiftAdd	SubArray.h	/^	ShiftAdd shiftAdd;$/;"	m	class:SubArray
shiftAddEnable	SubArray.h	/^	bool shiftAddEnable;    \/\/ 0 for partition because the shift-and-add circuit will be after the last A&R stage$/;"	m	class:SubArray
size	HWsim_wrap.cxx	/^  size_t                 size;		        \/* Number of types in this module *\/$/;"	m	struct:swig_module_info	file:
size	HWsim_wrap.cxx	/^  size_t size;$/;"	m	struct:__anon4	file:
slSwitchMatrix	SubArray.h	/^	SwitchMatrix    slSwitchMatrix;$/;"	m	class:SubArray
slots	HWsim_wrap.cxx	/^  PyObject *name, *slots;$/;"	m	struct:__anon1	file:
sources	setup.py	/^        sources=["HWsim_wrap.cxx",$/;"	v
spikingMode	ReadCircuit.h	/^	SpikingMode spikingMode;$/;"	m	class:ReadCircuit
spikingMode	ShiftAdd.h	/^	SpikingMode spikingMode;$/;"	m	class:ShiftAdd
spikingMode	SubArray.h	/^	SpikingMode spikingMode;	\/\/ NONSPIKING: input data using pulses in binary representation$/;"	m	class:SubArray
sramWriteDriver	SubArray.h	/^	SRAMWriteDriver sramWriteDriver;$/;"	m	class:SubArray
ssizeargfunc	HWsim_wrap.cxx	/^typedef intargfunc ssizeargfunc;$/;"	t	file:
ssizeobjargproc	HWsim_wrap.cxx	/^typedef intobjargproc ssizeobjargproc;$/;"	t	file:
ssizessizeargfunc	HWsim_wrap.cxx	/^typedef intintargfunc ssizessizeargfunc;$/;"	t	file:
ssizessizeobjargproc	HWsim_wrap.cxx	/^typedef intintobjargproc ssizessizeobjargproc;$/;"	t	file:
state	HWsim_wrap.cxx	/^         PyGILState_STATE state;$/;"	m	class:SWIG_Python_Thread_Block	file:
status	HWsim_wrap.cxx	/^         bool status;$/;"	m	class:SWIG_Python_Thread_Allow	file:
status	HWsim_wrap.cxx	/^         bool status;$/;"	m	class:SWIG_Python_Thread_Block	file:
str	HWsim_wrap.cxx	/^  const char             *str;			\/* human readable name of this type *\/$/;"	m	struct:swig_type_info	file:
strfind	tmp/addstring.py	/^        strfind = "    FunctionUnit::SaveOutput(str, outputFile);\\n"$/;"	v
strfind	tmp/addstring2.py	/^        strfind = "\\void SaveOutput(const char* str, const char* outputFile);\\r\\n"$/;"	v
string	tmp/addstring.py	/^        string = "void " + fn[0:-4] + "::SaveOutput(const char* str, const char* outputFile)\\n{\\n    FunctionUnit::SaveOutput(str, outputFile);\\n}"$/;"	v
string	tmp/addstring2.py	/^        string = "\\tvoid SaveOutput(const char* str, const char* outputFile);\\n"$/;"	v
subArray	Core.h	/^	SubArray subArray;$/;"	m	class:Core
sum_add	Core.h	/^	Sum sum_add;$/;"	m	class:Core
swig	HWsim_wrap.cxx	/^namespace swig {$/;"	n	file:
swig_cast_info	HWsim_wrap.cxx	/^typedef struct swig_cast_info {$/;"	s	file:
swig_cast_info	HWsim_wrap.cxx	/^} swig_cast_info;$/;"	t	typeref:struct:swig_cast_info	file:
swig_cast_initial	HWsim_wrap.cxx	/^static swig_cast_info *swig_cast_initial[] = {$/;"	v	file:
swig_const_info	HWsim_wrap.cxx	/^typedef struct swig_const_info {$/;"	s	file:
swig_const_info	HWsim_wrap.cxx	/^} swig_const_info;$/;"	t	typeref:struct:swig_const_info	file:
swig_const_table	HWsim_wrap.cxx	/^static swig_const_info swig_const_table[] = {$/;"	v	file:
swig_converter_func	HWsim_wrap.cxx	/^typedef void *(*swig_converter_func)(void *, int *);$/;"	t	file:
swig_dycast_func	HWsim_wrap.cxx	/^typedef struct swig_type_info *(*swig_dycast_func)(void **);$/;"	t	typeref:struct:swig_dycast_func	file:
swig_globalvar	HWsim_wrap.cxx	/^  typedef struct swig_globalvar {$/;"	s	file:
swig_globalvar	HWsim_wrap.cxx	/^  } swig_globalvar;$/;"	t	typeref:struct:swig_globalvar	file:
swig_import_helper	HWsim.py	/^    def swig_import_helper():$/;"	f
swig_import_helper	build/lib.linux-x86_64-2.7/HWsim.py	/^    def swig_import_helper():$/;"	f
swig_import_helper	tmp/HWsim.py	/^    def swig_import_helper():$/;"	f
swig_module	HWsim_wrap.cxx	/^static swig_module_info swig_module = {swig_types, 8, 0, 0, 0, 0};$/;"	v	file:
swig_module_info	HWsim_wrap.cxx	/^typedef struct swig_module_info {$/;"	s	file:
swig_module_info	HWsim_wrap.cxx	/^} swig_module_info;$/;"	t	typeref:struct:swig_module_info	file:
swig_owntype	HWsim_wrap.cxx	1195;"	d	file:
swig_this	HWsim_wrap.cxx	/^static PyObject *swig_this = NULL;$/;"	v	file:
swig_type_info	HWsim_wrap.cxx	/^typedef struct swig_type_info {$/;"	s	file:
swig_type_info	HWsim_wrap.cxx	/^} swig_type_info;$/;"	t	typeref:struct:swig_type_info	file:
swig_type_initial	HWsim_wrap.cxx	/^static swig_type_info *swig_type_initial[] = {$/;"	v	file:
swig_types	HWsim_wrap.cxx	/^static swig_type_info *swig_types[9];$/;"	v	file:
swig_varlink_dealloc	HWsim_wrap.cxx	/^  swig_varlink_dealloc(swig_varlinkobject *v) {$/;"	f
swig_varlink_getattr	HWsim_wrap.cxx	/^  swig_varlink_getattr(swig_varlinkobject *v, char *n) {$/;"	f
swig_varlink_print	HWsim_wrap.cxx	/^  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {$/;"	f
swig_varlink_setattr	HWsim_wrap.cxx	/^  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {$/;"	f
swig_varlink_str	HWsim_wrap.cxx	/^  swig_varlink_str(swig_varlinkobject *v) {$/;"	f
swig_varlink_type	HWsim_wrap.cxx	/^  swig_varlink_type(void) {$/;"	f
swig_varlinkobject	HWsim_wrap.cxx	/^  typedef struct swig_varlinkobject {$/;"	s	file:
swig_varlinkobject	HWsim_wrap.cxx	/^  } swig_varlinkobject;$/;"	t	typeref:struct:swig_varlinkobject	file:
swigobject_methods	HWsim_wrap.cxx	/^swigobject_methods[] = {$/;"	v	file:
synapsebit	tmp/ParameterData.h	/^	int synapsebit;                                    \/\/ # of bits of the synapse$/;"	m	class:ParameterData
synapserange	tmp/ParameterData.h	/^	int synapserange;                 \/\/ the value range of synapse$/;"	m	class:ParameterData
tech	ActivationFunc.h	/^	const Technology& tech;$/;"	m	class:ActivationFunc
tech	Adder.h	/^	const Technology& tech;$/;"	m	class:Adder
tech	Comparator.h	/^	const Technology& tech;$/;"	m	class:Comparator
tech	Core.h	/^	const Technology& tech;$/;"	m	class:Core
tech	CurrentSenseAmp.h	/^	const Technology& tech;$/;"	m	class:CurrentSenseAmp
tech	DFF.h	/^	const Technology& tech;$/;"	m	class:DFF
tech	DeMux.h	/^	const Technology& tech;$/;"	m	class:DeMux
tech	DecoderDriver.h	/^	const Technology& tech;$/;"	m	class:DecoderDriver
tech	HWsim.h	/^	Technology tech;$/;"	m	class:HWsim
tech	LUT.h	/^	const Technology& tech;$/;"	m	class:LUT
tech	MultilevelSAEncoder.h	/^	const Technology& tech;$/;"	m	class:MultilevelSAEncoder
tech	MultilevelSenseAmp.h	/^	const Technology& tech;$/;"	m	class:MultilevelSenseAmp
tech	Mux.h	/^	const Technology& tech;$/;"	m	class:Mux
tech	NewSwitchMatrix.h	/^	const Technology& tech;$/;"	m	class:NewSwitchMatrix
tech	Precharger.h	/^	const Technology& tech;$/;"	m	class:Precharger
tech	ReadCircuit.h	/^	const Technology& tech;$/;"	m	class:ReadCircuit
tech	RippleCounter.h	/^	const Technology& tech;$/;"	m	class:RippleCounter
tech	RowDecoder.h	/^	const Technology& tech;$/;"	m	class:RowDecoder
tech	SRAMWriteDriver.h	/^	const Technology& tech;$/;"	m	class:SRAMWriteDriver
tech	SenseAmp.h	/^	const Technology& tech;$/;"	m	class:SenseAmp
tech	ShiftAdd.h	/^	const Technology& tech;$/;"	m	class:ShiftAdd
tech	SubArray.h	/^	Technology& tech;$/;"	m	class:SubArray
tech	Sum.h	/^	const Technology& tech;$/;"	m	class:Sum
tech	SwitchMatrix.h	/^	const Technology& tech;$/;"	m	class:SwitchMatrix
tech	VoltageSenseAmp.h	/^	const Technology& tech;$/;"	m	class:VoltageSenseAmp
tech	WLDecoderOutput.h	/^	const Technology& tech;$/;"	m	class:WLDecoderOutput
tech	WLNewDecoderDriver.h	/^	const Technology& tech;$/;"	m	class:WLNewDecoderDriver
tech	tmp/test/test_core.cpp	/^Technology tech;$/;"	v
temperature	InputParameter.h	/^	int temperature;				\/* The ambient temperature, Unit: K *\/$/;"	m	class:InputParameter
temperature	ReadParam.h	/^	int temperature;				\/* The ambient temperature, Unit: K *\/$/;"	m	class:ReadParam
totalArea	FunctionUnit.h	/^	double totalArea;		\/* Unit: m^2 *\/$/;"	m	class:FunctionUnit
transistorType	InputParameter.h	/^	TransistorType transistorType;	\/* Conventional CMOS, 2D FET, or TFET *\/$/;"	m	class:InputParameter
transistorType	ReadParam.h	/^	TransistorType transistorType;  \/* Conventional CMOS, 2D FET, or TF    ET *\/$/;"	m	class:ReadParam
transistorType	Technology.h	/^	TransistorType transistorType;$/;"	m	class:Technology
tsqinghua	SubArray.h	/^	bool tsqinghua;       \/\/ tsqinghua's design (crossbar array)$/;"	m	class:SubArray
ty	HWsim_wrap.cxx	/^  swig_type_info *ty;$/;"	m	struct:__anon3	file:
ty	HWsim_wrap.cxx	/^  swig_type_info *ty;$/;"	m	struct:__anon4	file:
type	HWsim_wrap.cxx	/^  PyTypeObject type;$/;"	m	struct:__anon1	file:
type	HWsim_wrap.cxx	/^  int type;$/;"	m	struct:swig_const_info	file:
type	HWsim_wrap.cxx	/^  swig_type_info         *type;			\/* pointer to type that is equivalent to this type *\/$/;"	m	struct:swig_cast_info	file:
type_initial	HWsim_wrap.cxx	/^  swig_type_info         **type_initial;	\/* Array of initially generated type structures *\/$/;"	m	struct:swig_module_info	file:
types	HWsim_wrap.cxx	/^  swig_type_info         **types;		\/* Array of pointers to swig_type_info structures that are in this module *\/$/;"	m	struct:swig_module_info	file:
unitWireRes	SubArray.h	/^	double unitWireRes;	\/\/ Unit wire resistance, Unit ohm\/m$/;"	m	class:SubArray
usedArea	FunctionUnit.h	/^	double usedArea;		\/* Unit: m^2 *\/$/;"	m	class:FunctionUnit
vars	HWsim_wrap.cxx	/^    swig_globalvar *vars;$/;"	m	struct:swig_varlinkobject	file:
vdd	Technology.h	/^	double vdd;			\/* Supply voltage, Unit: V *\/$/;"	m	class:Technology
version	setup.py	/^        version = "0.1",$/;"	v
voltageIntThreshold	ReadCircuit.h	/^	double voltageIntThreshold;$/;"	m	class:ReadCircuit
voltageSenseAmp	LUT.h	/^	VoltageSenseAmp voltageSenseAmp;$/;"	m	class:LUT
voltageSenseAmp	SubArray.h	/^	VoltageSenseAmp voltageSenseAmp;$/;"	m	class:SubArray
voltageSenseDiff	VoltageSenseAmp.h	/^	double voltageSenseDiff;$/;"	m	class:VoltageSenseAmp
vth	Technology.h	/^	double vth;				\/* Threshold voltage, Unit: V *\/$/;"	m	class:Technology
wAdder	Adder.h	/^	double hAdder, wAdder;$/;"	m	class:Adder
wDff	ReadCircuit.h	/^	double areaUnit, hUnit, wUnit, areaReadBody, hReadBody, wReadBody, areaDff, hDff, wDff;$/;"	m	class:ReadCircuit
wInv	ActivationFunc.h	/^	double wInv, hInv;$/;"	m	class:ActivationFunc
wNand	ActivationFunc.h	/^	double wNand, hNand;$/;"	m	class:ActivationFunc
wNmosL	CurrentSenseAmp.h	/^	double hNmosL, wNmosL, hNmosS, wNmosS, hNmosM, wNmosM;$/;"	m	class:CurrentSenseAmp
wNmosM	CurrentSenseAmp.h	/^	double hNmosL, wNmosL, hNmosS, wNmosS, hNmosM, wNmosM;$/;"	m	class:CurrentSenseAmp
wNmosS	CurrentSenseAmp.h	/^	double hNmosL, wNmosL, hNmosS, wNmosS, hNmosM, wNmosM;$/;"	m	class:CurrentSenseAmp
wReadBody	ReadCircuit.h	/^	double areaUnit, hUnit, wUnit, areaReadBody, hReadBody, wReadBody, areaDff, hDff, wDff;$/;"	m	class:ReadCircuit
wUnit	ReadCircuit.h	/^	double areaUnit, hUnit, wUnit, areaReadBody, hReadBody, wReadBody, areaDff, hDff, wDff;$/;"	m	class:ReadCircuit
width	FunctionUnit.h	/^	double width;		\/* Unit: m *\/$/;"	m	class:FunctionUnit
widthAccessCMOS	MemCell.h	/^	double widthAccessCMOS;	\/* The gate width of CMOS access transistor, Unit: F *\/$/;"	m	class:MemCell
widthArray	CurrentSenseAmp.h	/^	double widthArray;$/;"	m	class:CurrentSenseAmp
widthArray	SubArray.h	/^	double widthArray;$/;"	m	class:SubArray
widthDffInvN	ReadCircuit.h	/^	double widthDffTgN, widthDffTgP, widthDffInvN, widthDffInvP, widthDffNorN, widthDffNorP, widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:ReadCircuit
widthDffInvP	ReadCircuit.h	/^	double widthDffTgN, widthDffTgP, widthDffInvN, widthDffInvP, widthDffNorN, widthDffNorP, widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:ReadCircuit
widthDffNorN	ReadCircuit.h	/^	double widthDffTgN, widthDffTgP, widthDffInvN, widthDffInvP, widthDffNorN, widthDffNorP, widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:ReadCircuit
widthDffNorP	ReadCircuit.h	/^	double widthDffTgN, widthDffTgP, widthDffInvN, widthDffInvP, widthDffNorN, widthDffNorP, widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:ReadCircuit
widthDffTgN	ReadCircuit.h	/^	double widthDffTgN, widthDffTgP, widthDffInvN, widthDffInvP, widthDffNorN, widthDffNorP, widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:ReadCircuit
widthDffTgP	ReadCircuit.h	/^	double widthDffTgN, widthDffTgP, widthDffInvN, widthDffInvP, widthDffNorN, widthDffNorP, widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:ReadCircuit
widthDriverInvN	RowDecoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP, widthNorN, widthNorP, widthDriverInvN, widthDriverInvP;$/;"	m	class:RowDecoder
widthDriverInvP	RowDecoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP, widthNorN, widthNorP, widthDriverInvN, widthDriverInvP;$/;"	m	class:RowDecoder
widthEnInvN	Mux.h	/^	double widthNandN, widthNandP, widthEnInvN, widthEnInvP, widthTgN, widthTgP, widthMuxInvN, widthMuxInvP;$/;"	m	class:Mux
widthEnInvP	Mux.h	/^	double widthNandN, widthNandP, widthEnInvN, widthEnInvP, widthTgN, widthTgP, widthMuxInvN, widthMuxInvP;$/;"	m	class:Mux
widthFin	Technology.h	/^	double widthFin;	\/* Fin width, Unit: m *\/$/;"	m	class:Technology
widthInFeatureSize	MemCell.h	/^	double widthInFeatureSize;	\/* Cell width, Unit: F *\/$/;"	m	class:MemCell
widthInvN	ActivationFunc.h	/^	double widthInvN, widthInvP;$/;"	m	class:ActivationFunc
widthInvN	Comparator.h	/^	double widthInvN, widthInvP, widthNand2N, widthNand2P, widthNand3N, widthNand3P;$/;"	m	class:Comparator
widthInvN	DFF.h	/^	double widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:DFF
widthInvN	DeMux.h	/^	double widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:DeMux
widthInvN	DecoderDriver.h	/^	double widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:DecoderDriver
widthInvN	LUT.h	/^	double widthInvN, widthInvP;$/;"	m	class:LUT
widthInvN	MultilevelSAEncoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP;$/;"	m	class:MultilevelSAEncoder
widthInvN	MultilevelSenseAmp.h	/^	double widthInvN;$/;"	m	class:MultilevelSenseAmp
widthInvN	ReadCircuit.h	/^	double widthDffTgN, widthDffTgP, widthDffInvN, widthDffInvP, widthDffNorN, widthDffNorP, widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:ReadCircuit
widthInvN	RowDecoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP, widthNorN, widthNorP, widthDriverInvN, widthDriverInvP;$/;"	m	class:RowDecoder
widthInvN	SRAMWriteDriver.h	/^	double widthInvN, widthInvP;$/;"	m	class:SRAMWriteDriver
widthInvN	ShiftAdd.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP;$/;"	m	class:ShiftAdd
widthInvN	WLDecoderOutput.h	/^	double widthNorN, widthNorP, widthInvN, widthInvP, widthTgN, widthTgP, widthNmos;$/;"	m	class:WLDecoderOutput
widthInvN	WLNewDecoderDriver.h	/^	double widthNandN, widthNandP, widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:WLNewDecoderDriver
widthInvP	ActivationFunc.h	/^	double widthInvN, widthInvP;$/;"	m	class:ActivationFunc
widthInvP	Comparator.h	/^	double widthInvN, widthInvP, widthNand2N, widthNand2P, widthNand3N, widthNand3P;$/;"	m	class:Comparator
widthInvP	DFF.h	/^	double widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:DFF
widthInvP	DeMux.h	/^	double widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:DeMux
widthInvP	DecoderDriver.h	/^	double widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:DecoderDriver
widthInvP	LUT.h	/^	double widthInvN, widthInvP;$/;"	m	class:LUT
widthInvP	MultilevelSAEncoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP;$/;"	m	class:MultilevelSAEncoder
widthInvP	ReadCircuit.h	/^	double widthDffTgN, widthDffTgP, widthDffInvN, widthDffInvP, widthDffNorN, widthDffNorP, widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:ReadCircuit
widthInvP	RowDecoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP, widthNorN, widthNorP, widthDriverInvN, widthDriverInvP;$/;"	m	class:RowDecoder
widthInvP	SRAMWriteDriver.h	/^	double widthInvN, widthInvP;$/;"	m	class:SRAMWriteDriver
widthInvP	ShiftAdd.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP;$/;"	m	class:ShiftAdd
widthInvP	WLDecoderOutput.h	/^	double widthNorN, widthNorP, widthInvN, widthInvP, widthTgN, widthTgP, widthNmos;$/;"	m	class:WLDecoderOutput
widthInvP	WLNewDecoderDriver.h	/^	double widthNandN, widthNandP, widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:WLNewDecoderDriver
widthMuxInvN	Mux.h	/^	double widthNandN, widthNandP, widthEnInvN, widthEnInvP, widthTgN, widthTgP, widthMuxInvN, widthMuxInvP;$/;"	m	class:Mux
widthMuxInvP	Mux.h	/^	double widthNandN, widthNandP, widthEnInvN, widthEnInvP, widthTgN, widthTgP, widthMuxInvN, widthMuxInvP;$/;"	m	class:Mux
widthNand2N	Comparator.h	/^	double widthInvN, widthInvP, widthNand2N, widthNand2P, widthNand3N, widthNand3P;$/;"	m	class:Comparator
widthNand2P	Comparator.h	/^	double widthInvN, widthInvP, widthNand2N, widthNand2P, widthNand3N, widthNand3P;$/;"	m	class:Comparator
widthNand3N	Comparator.h	/^	double widthInvN, widthInvP, widthNand2N, widthNand2P, widthNand3N, widthNand3P;$/;"	m	class:Comparator
widthNand3P	Comparator.h	/^	double widthInvN, widthInvP, widthNand2N, widthNand2P, widthNand3N, widthNand3P;$/;"	m	class:Comparator
widthNandN	ActivationFunc.h	/^	double widthNandN, widthNandP;$/;"	m	class:ActivationFunc
widthNandN	Adder.h	/^	double widthNandN, widthNandP;$/;"	m	class:Adder
widthNandN	MultilevelSAEncoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP;$/;"	m	class:MultilevelSAEncoder
widthNandN	Mux.h	/^	double widthNandN, widthNandP, widthEnInvN, widthEnInvP, widthTgN, widthTgP, widthMuxInvN, widthMuxInvP;$/;"	m	class:Mux
widthNandN	RowDecoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP, widthNorN, widthNorP, widthDriverInvN, widthDriverInvP;$/;"	m	class:RowDecoder
widthNandN	ShiftAdd.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP;$/;"	m	class:ShiftAdd
widthNandN	WLNewDecoderDriver.h	/^	double widthNandN, widthNandP, widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:WLNewDecoderDriver
widthNandP	ActivationFunc.h	/^	double widthNandN, widthNandP;$/;"	m	class:ActivationFunc
widthNandP	Adder.h	/^	double widthNandN, widthNandP;$/;"	m	class:Adder
widthNandP	MultilevelSAEncoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP;$/;"	m	class:MultilevelSAEncoder
widthNandP	Mux.h	/^	double widthNandN, widthNandP, widthEnInvN, widthEnInvP, widthTgN, widthTgP, widthMuxInvN, widthMuxInvP;$/;"	m	class:Mux
widthNandP	RowDecoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP, widthNorN, widthNorP, widthDriverInvN, widthDriverInvP;$/;"	m	class:RowDecoder
widthNandP	ShiftAdd.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP;$/;"	m	class:ShiftAdd
widthNandP	WLNewDecoderDriver.h	/^	double widthNandN, widthNandP, widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:WLNewDecoderDriver
widthNmos	CurrentSenseAmp.h	/^	double widthNmos, widthPmos;$/;"	m	class:CurrentSenseAmp
widthNmos	VoltageSenseAmp.h	/^	double widthNmos, widthPmos;$/;"	m	class:VoltageSenseAmp
widthNmos	WLDecoderOutput.h	/^	double widthNorN, widthNorP, widthInvN, widthInvP, widthTgN, widthTgP, widthNmos;$/;"	m	class:WLDecoderOutput
widthNmos1	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthNmos2	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthNmos3	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthNmos4	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthNmos5	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthNmos6	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthNmos7	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthNmos8	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthNorN	RowDecoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP, widthNorN, widthNorP, widthDriverInvN, widthDriverInvP;$/;"	m	class:RowDecoder
widthNorN	WLDecoderOutput.h	/^	double widthNorN, widthNorP, widthInvN, widthInvP, widthTgN, widthTgP, widthNmos;$/;"	m	class:WLDecoderOutput
widthNorP	RowDecoder.h	/^	double widthInvN, widthInvP, widthNandN, widthNandP, widthNorN, widthNorP, widthDriverInvN, widthDriverInvP;$/;"	m	class:RowDecoder
widthNorP	WLDecoderOutput.h	/^	double widthNorN, widthNorP, widthInvN, widthInvP, widthTgN, widthTgP, widthNmos;$/;"	m	class:WLDecoderOutput
widthPMOSBitlineEqual	Precharger.h	/^	double widthPMOSBitlinePrecharger, widthPMOSBitlineEqual;$/;"	m	class:Precharger
widthPMOSBitlinePrecharger	Precharger.h	/^	double widthPMOSBitlinePrecharger, widthPMOSBitlineEqual;$/;"	m	class:Precharger
widthPmos	CurrentSenseAmp.h	/^	double widthNmos, widthPmos;$/;"	m	class:CurrentSenseAmp
widthPmos	VoltageSenseAmp.h	/^	double widthNmos, widthPmos;$/;"	m	class:VoltageSenseAmp
widthPmos1	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthPmos3	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthPmos4	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthPmos5	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthPmos8	ReadCircuit.h	/^	double widthNmos1, widthPmos1, widthNmos2, widthNmos3, widthPmos3, widthNmos4, widthPmos4, widthNmos5, widthPmos5, widthNmos6, widthNmos7, widthNmos8, widthPmos8;$/;"	m	class:ReadCircuit
widthSRAMCellNMOS	MemCell.h	/^	double widthSRAMCellNMOS;	\/* The gate width of NMOS in SRAM cells, Unit: F *\/$/;"	m	class:MemCell
widthSRAMCellPMOS	MemCell.h	/^	double widthSRAMCellPMOS;	\/* The gate width of PMOS in SRAM cells, Unit: F *\/$/;"	m	class:MemCell
widthTgN	DFF.h	/^	double widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:DFF
widthTgN	DeMux.h	/^	double widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:DeMux
widthTgN	DecoderDriver.h	/^	double widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:DecoderDriver
widthTgN	Mux.h	/^	double widthNandN, widthNandP, widthEnInvN, widthEnInvP, widthTgN, widthTgP, widthMuxInvN, widthMuxInvP;$/;"	m	class:Mux
widthTgN	NewSwitchMatrix.h	/^	double widthTgN, widthTgP;$/;"	m	class:NewSwitchMatrix
widthTgN	ReadCircuit.h	/^	double widthDffTgN, widthDffTgP, widthDffInvN, widthDffInvP, widthDffNorN, widthDffNorP, widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:ReadCircuit
widthTgN	SwitchMatrix.h	/^	double widthTgN, widthTgP;$/;"	m	class:SwitchMatrix
widthTgN	WLDecoderOutput.h	/^	double widthNorN, widthNorP, widthInvN, widthInvP, widthTgN, widthTgP, widthNmos;$/;"	m	class:WLDecoderOutput
widthTgN	WLNewDecoderDriver.h	/^	double widthNandN, widthNandP, widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:WLNewDecoderDriver
widthTgP	DFF.h	/^	double widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:DFF
widthTgP	DeMux.h	/^	double widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:DeMux
widthTgP	DecoderDriver.h	/^	double widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:DecoderDriver
widthTgP	Mux.h	/^	double widthNandN, widthNandP, widthEnInvN, widthEnInvP, widthTgN, widthTgP, widthMuxInvN, widthMuxInvP;$/;"	m	class:Mux
widthTgP	NewSwitchMatrix.h	/^	double widthTgN, widthTgP;$/;"	m	class:NewSwitchMatrix
widthTgP	ReadCircuit.h	/^	double widthDffTgN, widthDffTgP, widthDffInvN, widthDffInvP, widthDffNorN, widthDffNorP, widthTgN, widthTgP, widthInvN, widthInvP;$/;"	m	class:ReadCircuit
widthTgP	SwitchMatrix.h	/^	double widthTgN, widthTgP;$/;"	m	class:SwitchMatrix
widthTgP	WLDecoderOutput.h	/^	double widthNorN, widthNorP, widthInvN, widthInvP, widthTgN, widthTgP, widthNmos;$/;"	m	class:WLDecoderOutput
widthTgP	WLNewDecoderDriver.h	/^	double widthNandN, widthNandP, widthInvN, widthInvP, widthTgN, widthTgP;$/;"	m	class:WLNewDecoderDriver
widthTgShared	Mux.h	/^	double widthTgShared;$/;"	m	class:Mux
widthVoltageSenseAmp	VoltageSenseAmp.h	/^	double widthVoltageSenseAmp;$/;"	m	class:VoltageSenseAmp
wireWidth	HWsim.h	/^	int wireWidth;	\/* The Width of the wire, unit: nm*\/$/;"	m	class:HWsim
wireWidth	ReadParam.h	/^	int wireWidth;					\/* Interwire Width, Unit: nm *\/$/;"	m	class:ReadParam
wireWidth	tmp/ParameterData.h	/^	int wireWidth;$/;"	m	class:ParameterData
wireWidth	tmp/test/test_core.cpp	/^int wireWidth = 40;$/;"	v
wlDecoder	SubArray.h	/^	RowDecoder  wlDecoder;$/;"	m	class:SubArray
wlDecoderDriver	SubArray.h	/^	DecoderDriver wlDecoderDriver;$/;"	m	class:SubArray
wlDecoderOutput	SubArray.h	/^	WLDecoderOutput wlDecoderOutput;$/;"	m	class:SubArray
wlNewDecoderDriver	SubArray.h	/^	WLNewDecoderDriver wlNewDecoderDriver;$/;"	m	class:SubArray
wlNewSwitchMatrix	SubArray.h	/^	NewSwitchMatrix wlNewSwitchMatrix;$/;"	m	class:SubArray
wlSwitchMatrix	SubArray.h	/^	SwitchMatrix    wlSwitchMatrix;$/;"	m	class:SubArray
writeDynamicEnergy	FunctionUnit.h	/^	double readDynamicEnergy, writeDynamicEnergy;	\/* Unit: J *\/$/;"	m	class:FunctionUnit
writeDynamicEnergyArray	SubArray.h	/^	double readDynamicEnergyArray, writeDynamicEnergyArray;$/;"	m	class:SubArray
writeLatency	FunctionUnit.h	/^	double readLatency, writeLatency;		\/* Unit: s *\/$/;"	m	class:FunctionUnit
writePower	FunctionUnit.h	/^	double readPower, writePower;$/;"	m	class:FunctionUnit
writePulseWidth	MemCell.h	/^	double writePulseWidth;$/;"	m	class:MemCell
writeVoltage	MemCell.h	/^	double writeVoltage;$/;"	m	class:MemCell
writebufferproc	HWsim_wrap.cxx	/^typedef getwritebufferproc writebufferproc;$/;"	t	file:
~ActivationFunc	ActivationFunc.h	/^	virtual ~ActivationFunc() {}$/;"	f	class:ActivationFunc
~Adder	Adder.h	/^	virtual ~Adder() {}$/;"	f	class:Adder
~Comparator	Comparator.h	/^	virtual ~Comparator() {}$/;"	f	class:Comparator
~Core	Core.h	/^	virtual ~Core() {}$/;"	f	class:Core
~CurrentSenseAmp	CurrentSenseAmp.cpp	/^CurrentSenseAmp::~CurrentSenseAmp() {$/;"	f	class:CurrentSenseAmp
~DFF	DFF.h	/^	virtual ~DFF() {}$/;"	f	class:DFF
~DeMux	DeMux.h	/^	virtual ~DeMux() {}$/;"	f	class:DeMux
~DecoderDriver	DecoderDriver.h	/^	virtual ~DecoderDriver() {}$/;"	f	class:DecoderDriver
~FunctionUnit	FunctionUnit.h	/^	virtual ~FunctionUnit() {}$/;"	f	class:FunctionUnit
~HWsim	HWsim.h	/^	virtual ~HWsim() {}$/;"	f	class:HWsim
~LUT	LUT.h	/^	virtual ~LUT() {}$/;"	f	class:LUT
~MultilevelSAEncoder	MultilevelSAEncoder.h	/^	virtual ~MultilevelSAEncoder() {}$/;"	f	class:MultilevelSAEncoder
~MultilevelSenseAmp	MultilevelSenseAmp.h	/^	virtual ~MultilevelSenseAmp() {}$/;"	f	class:MultilevelSenseAmp
~Mux	Mux.h	/^	virtual ~Mux() {}$/;"	f	class:Mux
~NewSwitchMatrix	NewSwitchMatrix.cpp	/^NewSwitchMatrix::~NewSwitchMatrix() {$/;"	f	class:NewSwitchMatrix
~ParameterData	tmp/ParameterData.h	/^	virtual ~ParameterData() {}$/;"	f	class:ParameterData
~Precharger	Precharger.h	/^	virtual ~Precharger() {}$/;"	f	class:Precharger
~ReadCircuit	ReadCircuit.h	/^	virtual ~ReadCircuit() {}$/;"	f	class:ReadCircuit
~ReadParam	ReadParam.h	/^	virtual ~ReadParam() {}$/;"	f	class:ReadParam
~RippleCounter	RippleCounter.h	/^	virtual ~RippleCounter() {}$/;"	f	class:RippleCounter
~RowDecoder	RowDecoder.h	/^	virtual ~RowDecoder() {}$/;"	f	class:RowDecoder
~SRAMWriteDriver	SRAMWriteDriver.h	/^	virtual ~SRAMWriteDriver() {}$/;"	f	class:SRAMWriteDriver
~SWIG_Python_Thread_Allow	HWsim_wrap.cxx	/^         ~SWIG_Python_Thread_Allow() { end(); }$/;"	f	class:SWIG_Python_Thread_Allow
~SWIG_Python_Thread_Block	HWsim_wrap.cxx	/^         ~SWIG_Python_Thread_Block() { end(); }$/;"	f	class:SWIG_Python_Thread_Block
~SenseAmp	SenseAmp.h	/^	virtual ~SenseAmp() {}$/;"	f	class:SenseAmp
~ShiftAdd	ShiftAdd.h	/^	virtual ~ShiftAdd() {}$/;"	f	class:ShiftAdd
~SubArray	SubArray.h	/^	virtual ~SubArray() {}$/;"	f	class:SubArray
~Sum	Sum.h	/^	virtual ~Sum() {}$/;"	f	class:Sum
~SwigMovePointer	HWsim_wrap.cxx	/^    ~SwigMovePointer() { delete ptr; }$/;"	f	struct:SwigValueWrapper::SwigMovePointer
~SwigPtr_PyObject	HWsim_wrap.cxx	/^    ~SwigPtr_PyObject() $/;"	f	class:swig::SwigPtr_PyObject
~SwitchMatrix	SwitchMatrix.h	/^	virtual ~SwitchMatrix() {}$/;"	f	class:SwitchMatrix
~Technology	Technology.h	/^	virtual ~Technology() {}$/;"	f	class:Technology
~VoltageSenseAmp	VoltageSenseAmp.h	/^	virtual ~VoltageSenseAmp() {}$/;"	f	class:VoltageSenseAmp
~WLDecoderOutput	WLDecoderOutput.h	/^	virtual ~WLDecoderOutput() {}$/;"	f	class:WLDecoderOutput
~WLNewDecoderDriver	WLNewDecoderDriver.cpp	/^WLNewDecoderDriver::~WLNewDecoderDriver() {$/;"	f	class:WLNewDecoderDriver
